<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BomberNet Engine</title>
    <style>
        /* RESET BÁSICO */
        body {
            margin: 0; padding: 0;
            background-color: #000;
            color: white;
            font-family: monospace;
            overflow: hidden; /* Sin barras de scroll */
            touch-action: none; /* Desactivar zoom táctil */
            height: 100vh; width: 100vw;
            display: flex; align-items: center; justify-content: center;
        }

        /* CONTENEDOR DEL JUEGO (Mantiene Aspect Ratio) */
        #game-container {
            position: relative;
            background: #111;
            box-shadow: 0 0 50px rgba(255, 159, 67, 0.2);
            /* Tamaño inicial por si falla JS */
            width: 480px; height: 352px; 
        }

        canvas {
            display: block;
            width: 100%; height: 100%;
            image-rendering: pixelated; /* PIXEL ART NÍTIDO */
        }

        /* CAPA DE UI (MENÚ) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.7); /* Semitransparente para ver el juego detrás */
            z-index: 100;
        }
        
        .panel {
            background: #222; padding: 20px; border: 4px solid #fff;
            box-shadow: 0 10px 0 #000; text-align: center;
        }

        input {
            display: block; margin: 10px auto; padding: 10px; font-size: 16px; 
            background: #000; color: #fff; border: 2px solid #555; text-align: center;
            font-family: monospace; text-transform: uppercase;
        }
        
        button {
            padding: 10px 20px; font-size: 16px; cursor: pointer;
            background: #ff9f43; color: #000; border: 2px solid #fff;
            font-weight: bold; font-family: monospace; text-transform: uppercase;
        }
        button:active { transform: translateY(4px); box-shadow: none; }

        /* CONTROLES TÁCTILES */
        #mobile-controls {
            display: none; position: absolute; bottom: 10px; left: 10px;
            width: 140px; height: 140px; z-index: 50;
        }
        .d-pad-btn {
            position: absolute; width: 40px; height: 40px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 5px;
        }
        .d-pad-btn:active { background: rgba(255, 159, 67, 0.5); }
        
        #btn-up { top: 0; left: 50px; }
        #btn-down { bottom: 0; left: 50px; }
        #btn-left { top: 50px; left: 0; }
        #btn-right { top: 50px; right: 0; }

        #action-btn {
            display: none; position: absolute; bottom: 20px; right: 20px;
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(231, 76, 60, 0.4); border: 4px solid rgba(255,255,255,0.4);
            z-index: 50;
        }
        #action-btn:active { background: rgba(231, 76, 60, 0.8); }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- MENÚ PRINCIPAL -->
        <div id="ui-layer">
            <div class="panel">
                <h1 style="color:#ff9f43; margin-bottom:5px;">BOMBER-NET</h1>
                <div style="font-size:10px; color:#aaa; margin-bottom:15px;">HTML5 ENGINE v0.2</div>
                
                <input type="text" id="roomInput" placeholder="SALA (EJ: TEST)" value="TEST" maxlength="6">
                <button id="btnPlay" onclick="startGame()">CONECTAR</button>
                <div id="status-log" style="margin-top:10px; font-size:10px; color:#4cd137;">ONLINE</div>
            </div>
        </div>

        <!-- TOUCH CONTROLS -->
        <div id="mobile-controls">
            <div id="btn-up" class="d-pad-btn"></div>
            <div id="btn-down" class="d-pad-btn"></div>
            <div id="btn-left" class="d-pad-btn"></div>
            <div id="btn-right" class="d-pad-btn"></div>
        </div>
        <div id="action-btn"></div>
    </div>

<script>
/** * CONFIGURACIÓN DEL MOTOR
 */
const CONFIG = {
    RES_W: 480,  // Ancho lógico (15 celdas * 32px)
    RES_H: 352,  // Alto lógico (11 celdas * 32px)
    TILE: 32,    // Tamaño de celda
    FPS: 60
};

// --- ESTADO DEL JUEGO ---
const state = {
    running: false,
    connected: false,
    input: { x:0, y:0, action:false },
    localPlayer: null,
    remotePlayer: null
};

// --- RED (NETWORK) ---
class Net {
    constructor() {
        this.ws = null;
        this.rtc = null;
        this.channel = null;
        this.id = 0;
    }

    connect(room) {
        log("Conectando WS...");
        this.ws = new WebSocket('wss://bomber-server.onrender.com');
        this.ws.onopen = () => this.ws.send(JSON.stringify({ type:'join', room:room }));
        this.ws.onmessage = (e) => this.handleSig(JSON.parse(e.data));
    }

    async handleSig(msg) {
        switch(msg.type) {
            case 'id': 
                this.id = msg.id; 
                onConnected(msg.id); 
                break;
            case 'peer_connected': 
                this.initRTC(true); 
                break;
            case 'offer': 
                if(!this.rtc) this.initRTC(false);
                await this.rtc.setRemoteDescription(msg.sdp);
                // Breve pausa para estabilidad
                setTimeout(async () => {
                    const ans = await this.rtc.createAnswer();
                    await this.rtc.setLocalDescription(ans);
                    this.sendSig({ type:'answer', sdp:ans });
                }, 100);
                break;
            case 'answer': 
                await this.rtc.setRemoteDescription(msg.sdp); 
                break;
            case 'candidate': 
                if(this.rtc) await this.rtc.addIceCandidate(msg.candidate); 
                break;
        }
    }

    sendSig(data) { if(this.ws) this.ws.send(JSON.stringify(data)); }

    initRTC(isOfferer) {
        log("Iniciando WebRTC...");
        this.rtc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
        
        this.rtc.onicecandidate = e => { if(e.candidate) this.sendSig({type:'candidate', candidate:e.candidate}); };
        this.rtc.onconnectionstatechange = () => {
            if(this.rtc.connectionState === 'connected') onPeerJoin();
        };

        if(isOfferer) {
            this.channel = this.rtc.createDataChannel("game", {ordered:false, maxRetransmits:0});
            this.setupChannel();
            this.rtc.createOffer().then(o => { this.rtc.setLocalDescription(o); this.sendSig({type:'offer', sdp:o}); });
        } else {
            this.rtc.ondatachannel = e => { this.channel = e.channel; this.setupChannel(); };
        }
    }

    setupChannel() {
        this.channel.onmessage = e => onNetData(JSON.parse(e.data));
        this.channel.onopen = () => log("¡CANAL P2P ABIERTO!");
    }

    send(data) {
        if(this.channel && this.channel.readyState==='open') this.channel.send(JSON.stringify(data));
    }
}

// --- CLASES DE JUEGO ---
class Player {
    constructor(id, x, y, color) {
        this.id = id;
        this.x = x; this.y = y;
        this.tx = x; this.ty = y; // Target (para interpolación)
        this.color = color;
        this.w = 24; this.h = 24; // Un poco más pequeño que el tile (32)
    }

    update() {
        // Interpolación suave hacia el objetivo
        this.x += (this.tx - this.x) * 0.2;
        this.y += (this.ty - this.y) * 0.2;
    }

    draw(ctx) {
        // Dibujar centrado en el tile
        // Las coordenadas x,y son top-left del tile lógico
        const cx = this.x + (CONFIG.TILE - this.w)/2;
        const cy = this.y + (CONFIG.TILE - this.h)/2;

        ctx.fillStyle = this.color;
        ctx.fillRect(cx, cy, this.w, this.h);
        
        // Ojos
        ctx.fillStyle = "white";
        ctx.fillRect(cx+4, cy+4, 6, 6);
        ctx.fillRect(cx+14, cy+4, 6, 6);
    }
}

// --- MOTOR GRÁFICO ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const net = new Net();

function init() {
    // Configurar Canvas
    ctx.imageSmoothingEnabled = false;
    resize();
    window.addEventListener('resize', resize);
    
    // Inputs
    setupInputs();

    // Arrancar Loop INMEDIATAMENTE para ver el grid
    requestAnimationFrame(loop);
}

function resize() {
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const scale = Math.min(winW / CONFIG.RES_W, winH / CONFIG.RES_H);
    
    const cont = document.getElementById('game-container');
    cont.style.width = (CONFIG.RES_W * scale) + 'px';
    cont.style.height = (CONFIG.RES_H * scale) + 'px';
    
    // Canvas interno siempre tiene resolución lógica fija
    canvas.width = CONFIG.RES_W;
    canvas.height = CONFIG.RES_H;
    ctx.imageSmoothingEnabled = false; // Reaplicar al redimensionar
}

// --- LOGICA DE JUEGO ---
function startGame() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    document.getElementById('btnPlay').disabled = true;
    document.getElementById('btnPlay').innerText = "CONECTANDO...";
    net.connect(room.toUpperCase());
}

function onConnected(myId) {
    document.getElementById('ui-layer').style.display = 'none';
    state.connected = true;
    
    // Spawn propio
    const color = myId===1 ? '#3498db' : '#e74c3c';
    // Posición inicial: 1,1 o Esquina opuesta
    const sx = myId===1 ? CONFIG.TILE : CONFIG.RES_W - CONFIG.TILE*2;
    const sy = myId===1 ? CONFIG.TILE : CONFIG.RES_H - CONFIG.TILE*2;
    
    state.localPlayer = new Player(myId, sx, sy, color);
    
    // Activar controles táctiles si es móvil
    if('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        document.getElementById('action-btn').style.display = 'block';
    }
}

function onPeerJoin() {
    log("¡RIVAL ENTRÓ!");
    const rivalId = state.localPlayer.id === 1 ? 2 : 1;
    const color = rivalId===1 ? '#3498db' : '#e74c3c';
    const sx = rivalId===1 ? CONFIG.TILE : CONFIG.RES_W - CONFIG.TILE*2;
    const sy = rivalId===1 ? CONFIG.TILE : CONFIG.RES_H - CONFIG.TILE*2;
    
    state.remotePlayer = new Player(rivalId, sx, sy, color);
}

function onNetData(data) {
    if(state.remotePlayer && data.t === 'm') {
        state.remotePlayer.tx = data.x;
        state.remotePlayer.ty = data.y;
    }
}

// --- BUCLE PRINCIPAL ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    if(!state.localPlayer) return;

    // Movimiento Local
    const SPEED = 2.5;
    let dx=0, dy=0;
    
    if(state.input.y < 0) dy = -SPEED;
    if(state.input.y > 0) dy = SPEED;
    if(state.input.x < 0) dx = -SPEED;
    if(state.input.x > 0) dx = SPEED;

    const p = state.localPlayer;
    let nx = p.tx + dx;
    let ny = p.ty + dy;

    // Colisiones Bordes Mapa
    if(nx < CONFIG.TILE) nx = CONFIG.TILE;
    if(ny < CONFIG.TILE) ny = CONFIG.TILE;
    if(nx > CONFIG.RES_W - CONFIG.TILE*2) nx = CONFIG.RES_W - CONFIG.TILE*2;
    if(ny > CONFIG.RES_H - CONFIG.TILE*2) ny = CONFIG.RES_H - CONFIG.TILE*2;

    p.tx = nx;
    p.ty = ny;
    p.update(); // Interpolar localmente también para suavidad visual

    // Enviar Red (Solo si me muevo)
    if(dx!==0 || dy!==0) {
        net.send({ t:'m', x:p.tx, y:p.ty });
    }

    if(state.remotePlayer) state.remotePlayer.update();
}

function draw() {
    // 1. Fondo
    ctx.fillStyle = "#2b3a42";
    ctx.fillRect(0,0, canvas.width, canvas.height);

    // 2. Grid (Suelo)
    const T = CONFIG.TILE;
    for(let y=0; y<CONFIG.RES_H; y+=T) {
        for(let x=0; x<CONFIG.RES_W; x+=T) {
            // Bordes Fijos (Pared Indestructible)
            if(x===0 || y===0 || x>=CONFIG.RES_W-T || y>=CONFIG.RES_H-T) {
                ctx.fillStyle = "#535c68"; // Pared Gris
                ctx.fillRect(x,y,T,T);
                drawPixelBorder(x,y,T, "#2c3e50");
            } else if ((x/T)%2===0 && (y/T)%2===0) {
                // Pilares internos
                ctx.fillStyle = "#535c68";
                ctx.fillRect(x,y,T,T);
                drawPixelBorder(x,y,T, "#2c3e50");
            } else {
                // Suelo Caminable
                ctx.strokeStyle = "rgba(255,255,255,0.03)";
                ctx.lineWidth = 1;
                ctx.strokeRect(x,y,T,T);
            }
        }
    }

    // 3. Jugadores
    if(state.remotePlayer) state.remotePlayer.draw(ctx);
    if(state.localPlayer) state.localPlayer.draw(ctx);
}

function drawPixelBorder(x, y, s, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y+s-4, s, 4); // Sombra abajo
    ctx.fillRect(x+s-4, y, 4, s); // Sombra derecha
}

// --- INPUTS ---
function setupInputs() {
    // Teclado
    window.onkeydown = e => {
        if(e.key==='ArrowUp' || e.key==='w') state.input.y = -1;
        if(e.key==='ArrowDown' || e.key==='s') state.input.y = 1;
        if(e.key==='ArrowLeft' || e.key==='a') state.input.x = -1;
        if(e.key==='ArrowRight' || e.key==='d') state.input.x = 1;
    };
    window.onkeyup = e => {
        if(['ArrowUp','w','ArrowDown','s'].includes(e.key)) state.input.y = 0;
        if(['ArrowLeft','a','ArrowRight','d'].includes(e.key)) state.input.x = 0;
    };

    // Touch
    bindTouch('btn-up', 0, -1);
    bindTouch('btn-down', 0, 1);
    bindTouch('btn-left', -1, 0);
    bindTouch('btn-right', 1, 0);
}

function bindTouch(id, x, y) {
    const el = document.getElementById(id);
    el.ontouchstart = (e) => { e.preventDefault(); state.input.x = x; state.input.y = y; };
    el.ontouchend = (e) => { e.preventDefault(); if(state.input.x===x) state.input.x=0; if(state.input.y===y) state.input.y=0; };
}

function log(msg) { console.log(msg); }

// Arrancar
window.onload = init;

</script>
</body>
</html>