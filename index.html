<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BomberNet Web Engine</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Evitar scroll en móvil */
            touch-action: none; /* Vital para controles táctiles */
        }

        /* --- UI DE MENÚ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
        }
        
        .panel {
            background: #2a2a2a; padding: 30px; border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); text-align: center;
            border: 1px solid #444;
        }

        h1 { margin: 0 0 20px 0; color: #ff9f43; letter-spacing: 2px; }
        
        input {
            padding: 12px; font-size: 18px; border-radius: 5px; border: none;
            background: #444; color: white; width: 200px; text-align: center;
            margin-bottom: 15px; outline: none; text-transform: uppercase;
        }
        
        button {
            padding: 12px 30px; font-size: 18px; cursor: pointer;
            background: #ff9f43; color: #222; border: none; border-radius: 5px;
            font-weight: bold; transition: transform 0.1s; width: 100%;
        }
        button:active { transform: scale(0.95); }
        button:disabled { background: #555; cursor: not-allowed; transform: none; }

        #status-log {
            margin-top: 15px; font-size: 14px; color: #aaa; min-height: 20px;
        }

        /* --- JUEGO --- */
        canvas {
            display: block;
            margin: 0 auto;
            background: #2b3a42; /* Color del suelo */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* --- CONTROLES MÓVIL --- */
        #mobile-controls {
            display: none; /* Se activa con JS si es táctil */
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 150px; z-index: 50;
        }
        .d-pad-btn {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px; border: 2px solid rgba(255,255,255,0.4);
        }
        .d-pad-btn:active { background: rgba(255, 159, 67, 0.5); }
        #btn-up { top: 0; left: 50px; }
        #btn-down { bottom: 0; left: 50px; }
        #btn-left { top: 50px; left: 0; }
        #btn-right { top: 50px; right: 0; }

        #action-btn {
            display: none; position: absolute; bottom: 40px; right: 40px;
            width: 80px; height: 80px; border-radius: 50%;
            background: rgba(231, 76, 60, 0.4); border: 4px solid rgba(255,255,255,0.4);
        }
        #action-btn:active { background: rgba(231, 76, 60, 0.8); }

    </style>
</head>
<body>

    <!-- MENÚ DE INICIO -->
    <div id="ui-layer">
        <div class="panel">
            <h1>BOMBERNET</h1>
            <input type="text" id="roomInput" placeholder="CÓDIGO SALA" value="TEST" maxlength="6">
            <button id="btnPlay" onclick="startGame()">JUGAR</button>
            <div id="status-log">Listo para conectar...</div>
        </div>
    </div>

    <!-- CANVAS DEL JUEGO -->
    <canvas id="gameCanvas"></canvas>

    <!-- CONTROLES TÁCTILES -->
    <div id="mobile-controls">
        <div id="btn-up" class="d-pad-btn"></div>
        <div id="btn-down" class="d-pad-btn"></div>
        <div id="btn-left" class="d-pad-btn"></div>
        <div id="btn-right" class="d-pad-btn"></div>
    </div>
    <div id="action-btn"></div>

<script>
/**
 * ==========================================
 * MÓDULO DE RED (NETWORK MANAGER)
 * Encapsula toda la complejidad de WebRTC
 * ==========================================
 */
class NetworkManager {
    constructor(signalingUrl, iceServers) {
        this.url = signalingUrl;
        this.iceServers = iceServers;
        this.ws = null;
        this.rtcPeer = null;
        this.dataChannel = null;
        this.myId = 0;
        
        // Event Hooks (Callbacks)
        this.onConnect = (id) => {}; // Cuando conectamos al server
        this.onPeerJoin = () => {};  // Cuando entra alguien
        this.onPeerLeft = () => {};  // Cuando sale
        this.onData = (data) => {};  // Cuando recibimos datos de juego
        this.onLog = (msg) => console.log(`[NET] ${msg}`);
    }

    connect(room) {
        this.onLog("Conectando WS...");
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
            this.sendSignaling({ type: 'join', room: room });
        };

        this.ws.onmessage = (e) => this.handleSignaling(JSON.parse(e.data));
        this.ws.onerror = (e) => this.onLog("Error WS");
    }

    sendSignaling(data) {
        if(this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }

    async handleSignaling(data) {
        switch (data.type) {
            case 'id':
                this.myId = data.id;
                this.onConnect(this.myId);
                break;
            case 'peer_connected':
                this.initWebRTC(true); // Soy Host, inicio llamada
                break;
            case 'offer':
                if(!this.rtcPeer) this.initWebRTC(false);
                await this.rtcPeer.setRemoteDescription(data.sdp);
                const answer = await this.rtcPeer.createAnswer();
                await this.rtcPeer.setLocalDescription(answer);
                this.sendSignaling({ type: 'answer', sdp: answer });
                break;
            case 'answer':
                await this.rtcPeer.setRemoteDescription(data.sdp);
                break;
            case 'candidate':
                if(this.rtcPeer) await this.rtcPeer.addIceCandidate(data.candidate);
                break;
            case 'peer_disconnected':
                if(this.rtcPeer) this.rtcPeer.close();
                this.rtcPeer = null;
                this.onPeerLeft();
                break;
        }
    }

    initWebRTC(isInitiator) {
        this.rtcPeer = new RTCPeerConnection({ iceServers: this.iceServers });

        this.rtcPeer.onicecandidate = (e) => {
            if (e.candidate) this.sendSignaling({ type: 'candidate', candidate: e.candidate });
        };

        this.rtcPeer.onconnectionstatechange = () => {
            if(this.rtcPeer.connectionState === 'connected') {
                this.onPeerJoin();
            }
        };

        if (isInitiator) {
            this.dataChannel = this.rtcPeer.createDataChannel("game", { ordered: false, maxRetransmits: 0 }); // UDP-like
            this.setupDataChannel();
            this.rtcPeer.createOffer().then(offer => {
                this.rtcPeer.setLocalDescription(offer);
                this.sendSignaling({ type: 'offer', sdp: offer });
            });
        } else {
            this.rtcPeer.ondatachannel = (e) => {
                this.dataChannel = e.channel;
                this.setupDataChannel();
            };
        }
    }

    setupDataChannel() {
        this.dataChannel.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            this.onData(msg);
        };
    }

    send(data) {
        if(this.dataChannel && this.dataChannel.readyState === 'open') {
            this.dataChannel.send(JSON.stringify(data));
        }
    }
}

/**
 * ==========================================
 * LÓGICA DEL JUEGO (GAME ENGINE)
 * ==========================================
 */

const CONSTANTS = {
    GRID_SIZE: 40,
    SPEED: 4,
    PLAYER_SIZE: 30
};

// Objeto Jugador
class Player {
    constructor(id, color, x, y) {
        this.id = id;
        this.color = color;
        this.x = x;
        this.y = y;
        this.targetX = x; // Para interpolación
        this.targetY = y;
        this.name = `P${id}`;
    }

    draw(ctx) {
        // Dibujar cuerpo (Interpolamos visualmente entre x y targetX)
        // Lerp simple: movemos un 20% hacia el objetivo cada frame
        this.x += (this.targetX - this.x) * 0.2; 
        this.y += (this.targetY - this.y) * 0.2;

        // Sombra
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.arc(this.x + CONSTANTS.PLAYER_SIZE/2, this.y + CONSTANTS.PLAYER_SIZE - 5, 10, 0, Math.PI*2);
        ctx.fill();

        // Cuadrado (Cuerpo)
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, CONSTANTS.PLAYER_SIZE, CONSTANTS.PLAYER_SIZE);
        
        // Borde
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, this.y, CONSTANTS.PLAYER_SIZE, CONSTANTS.PLAYER_SIZE);

        // Nombre
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.x + CONSTANTS.PLAYER_SIZE/2, this.y - 8);
    }
}

// Variables Globales del Juego
let canvas, ctx;
let net;
let localPlayer = null;
let remotePlayer = null;
let isGameRunning = false;
let inputState = { up: false, down: false, left: false, right: false };

// --- INICIALIZACIÓN ---
window.onload = () => {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Configurar Red
    net = new NetworkManager(
        'wss://bomber-server.onrender.com', 
        [{ urls: 'stun:stun.l.google.com:19302' }]
    );

    net.onConnect = (id) => {
        document.getElementById('status-log').innerText = `Conectado. Eres Jugador ${id}`;
        document.getElementById('status-log').style.color = "#4cd137";
        
        // Iniciar partida
        initGame(id);
    };

    net.onPeerJoin = () => {
        console.log("¡Rival entró!");
        // Crear al rival en la posición opuesta
        const rivalId = localPlayer.id === 1 ? 2 : 1;
        remotePlayer = new Player(rivalId, rivalId === 1 ? '#3498db' : '#e74c3c', 0, 0); 
        // Reset position based on ID
        if(rivalId === 1) { remotePlayer.targetX = 40; remotePlayer.targetY = 40; }
        else { remotePlayer.targetX = canvas.width - 80; remotePlayer.targetY = canvas.height - 80; }
    };

    net.onData = (data) => {
        if(remotePlayer && data.t === 'm') {
            // Actualizar objetivo del rival (Interpolación)
            remotePlayer.targetX = data.x;
            remotePlayer.targetY = data.y;
        }
    };

    setupInputs();
};

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function startGame() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    
    document.getElementById('btnPlay').disabled = true;
    document.getElementById('status-log').innerText = "Conectando al servidor...";
    
    net.connect(room.toUpperCase());
}

function initGame(myId) {
    document.getElementById('ui-layer').style.display = 'none';
    
    // Detectar si es móvil para mostrar controles
    if('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        document.getElementById('action-btn').style.display = 'block';
    }

    // Crear mi jugador
    const color = myId === 1 ? '#3498db' : '#e74c3c'; // Azul P1, Rojo P2
    let startX = myId === 1 ? 40 : canvas.width - 80;
    let startY = myId === 1 ? 40 : canvas.height - 80;
    
    localPlayer = new Player(myId, color, startX, startY);
    
    isGameRunning = true;
    requestAnimationFrame(gameLoop);
}

// --- BUCLE PRINCIPAL (60 FPS) ---
function gameLoop() {
    if(!isGameRunning) return;

    update();
    draw();
    requestAnimationFrame(gameLoop);
}

function update() {
    if(!localPlayer) return;

    // 1. Movimiento Local
    let dx = 0;
    let dy = 0;
    if(inputState.up) dy -= CONSTANTS.SPEED;
    if(inputState.down) dy += CONSTANTS.SPEED;
    if(inputState.left) dx -= CONSTANTS.SPEED;
    if(inputState.right) dx += CONSTANTS.SPEED;

    // Normalizar diagonales
    if(dx !== 0 && dy !== 0) {
        dx *= 0.707;
        dy *= 0.707;
    }

    localPlayer.targetX += dx;
    localPlayer.targetY += dy;

    // Colisiones con bordes
    if(localPlayer.targetX < 0) localPlayer.targetX = 0;
    if(localPlayer.targetY < 0) localPlayer.targetY = 0;
    if(localPlayer.targetX > canvas.width - CONSTANTS.PLAYER_SIZE) localPlayer.targetX = canvas.width - CONSTANTS.PLAYER_SIZE;
    if(localPlayer.targetY > canvas.height - CONSTANTS.PLAYER_SIZE) localPlayer.targetY = canvas.height - CONSTANTS.PLAYER_SIZE;

    // Para el jugador local, la posición real es inmediata (sin lag percibido)
    localPlayer.x = localPlayer.targetX;
    localPlayer.y = localPlayer.targetY;

    // 2. Enviar Red (Si nos hemos movido)
    if(dx !== 0 || dy !== 0) {
        net.send({ t: 'm', x: localPlayer.x, y: localPlayer.y });
    }
}

function draw() {
    // Limpiar pantalla
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dibujar Rejilla (Suelo)
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1;
    for(let x=0; x<canvas.width; x+=CONSTANTS.GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    for(let y=0; y<canvas.height; y+=CONSTANTS.GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }

    // Dibujar Jugadores
    if(remotePlayer) remotePlayer.draw(ctx);
    if(localPlayer) localPlayer.draw(ctx);
}

// --- INPUTS (Teclado + Touch) ---
function setupInputs() {
    // Teclado
    window.addEventListener('keydown', (e) => setKey(e.key, true));
    window.addEventListener('keyup', (e) => setKey(e.key, false));

    // Touch D-PAD
    bindTouch('btn-up', 'up');
    bindTouch('btn-down', 'down');
    bindTouch('btn-left', 'left');
    bindTouch('btn-right', 'right');
}

function setKey(key, state) {
    if(key === 'ArrowUp' || key === 'w') inputState.up = state;
    if(key === 'ArrowDown' || key === 's') inputState.down = state;
    if(key === 'ArrowLeft' || key === 'a') inputState.left = state;
    if(key === 'ArrowRight' || key === 'd') inputState.right = state;
}

function bindTouch(id, action) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); inputState[action] = true; });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); inputState[action] = false; });
}

</script>
</body>
</html>