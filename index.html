<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bombardo v3.1</title>
    <style>
        /* --- LAYOUT PRINCIPAL --- */
        body {
            margin: 0; padding: 0; background-color: #111;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden; touch-action: none; font-family: 'Courier New', monospace;
            user-select: none; -webkit-user-select: none;
        }

        /* CONTENEDOR DEL JUEGO */
        #game-viewport {
            position: relative; background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); image-rendering: pixelated;
            width: 480px; height: 352px; /* 15x11 tiles de 32px */
            flex-shrink: 1; display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; }
        
        /* --- SISTEMA DE PANTALLAS (UI) --- */
        .screen-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.9); z-index: 100;
        }
        
        .panel { 
            background: #2c3e50; border: 4px solid #fff; padding: 20px; 
            text-align: center; min-width: 220px; box-sizing: border-box; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        h1 { color: #f1c40f; margin: 0 0 15px 0; font-size: 24px; text-shadow: 2px 2px #c0392b; }
        
        input { 
            padding: 10px; background: #000; color: #fff; border: 2px solid #555; 
            text-align: center; display: block; margin: 0 auto 15px auto; 
            width: 150px; text-transform: uppercase; font-size: 16px; 
        }
        
        button { 
            padding: 12px 20px; background: #e74c3c; color: white; border: 2px solid #fff; 
            font-weight: bold; width: 100%; font-size: 16px; cursor: pointer; margin-top: 5px; 
        }
        button:active { transform: scale(0.95); background: #c0392b; }
        button:disabled { background: #555; color: #888; border-color: #555; cursor: not-allowed; transform: none; }
        
        #login-log { font-size: 11px; color: #aaa; margin-top: 10px; min-height: 14px; }

        /* --- LOBBY UI --- */
        .lobby-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .player-slot { 
            background: #333; padding: 10px; border: 2px solid #555; 
            color: #777; font-size: 12px; font-weight: bold; 
        }
        .player-slot.active { border-color: #fff; color: #fff; }
        .player-slot.p1.active { background: #3498db; }
        .player-slot.p2.active { background: #e74c3c; }
        .player-slot.p3.active { background: #2ecc71; }
        .player-slot.p4.active { background: #f1c40f; }

        /* HUD JUEGO */
        #hud { 
            position: absolute; top: 0; left: 0; width: 100%; 
            display: flex; flex-wrap: wrap; justify-content: space-around; 
            padding: 5px; pointer-events: none; z-index: 10; box-sizing: border-box;
        }
        .score-box { 
            background: rgba(0,0,0,0.6); padding: 4px 8px; color: white; 
            font-weight: bold; border: 1px solid rgba(255,255,255,0.3); 
            font-size: 12px; text-shadow: 1px 1px 0 #000; margin: 2px; 
        }
        #p1-score { color: #3498db; } #p2-score { color: #e74c3c; } 
        #p3-score { color: #2ecc71; } #p4-score { color: #f1c40f; }
        
        /* OVERLAY GAME OVER */
        #game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
        }

        /* --- CONTROLES MVILES --- */
        #gamepad-area {
            display: none; width: 100%; min-height: 240px; 
            background: #1a1a1a; border-top: 4px solid #333;
            flex-direction: row; justify-content: space-between; align-items: flex-start;
            padding: 20px 30px; padding-bottom: max(20px, env(safe-area-inset-bottom));
            box-sizing: border-box; flex-shrink: 0;
        }
        
        .gp-btn { 
            position: absolute; 
            background-image: url('sprites.png'); 
            background-repeat: no-repeat; 
            image-rendering: pixelated; 
        }
        .gp-btn:active { filter: brightness(1.2); transform: scale(0.95); }
        
        .d-pad { position: relative; width: 180px; height: 180px; }
        
        /* AJUSTE DE BOTONES UI:
           Escala 2x para los botones de flecha (32px -> 64px).
           Sheet original: 224x128. Scaled 2x: 448px 256px.
           Flecha (Up): Tile 2,3 (x=64, y=96) -> Scaled: 128, 192 -> Pos: -128px -192px.
        */
        .arrow-btn { 
            width: 64px; height: 64px; 
            background-size: 448px 256px; 
            background-position: -128px -192px; 
        }
        
        #btn-up { left: 58px; top: 0; } 
        #btn-down { left: 58px; bottom: 0; transform: rotate(180deg); }
        #btn-left { left: 0; top: 58px; transform: rotate(-90deg); } 
        #btn-right { right: 0; top: 58px; transform: rotate(90deg); }
        
        #action-wrapper { 
            position: relative; width: 120px; height: 120px; 
            display: flex; justify-content: center; align-items: center; margin-top: 20px; 
        }
        
        /* AJUSTE DE BOTN BOMBA:
           Escala 2.5x para llenar el bot贸n de 80px (32px * 2.5 = 80px).
           Sheet Scaled 2.5x: 560px 320px.
           Bomba: Tile 2,1 (x=64, y=32) -> Scaled: 160, 80 -> Pos: -160px -80px.
        */
        #action-btn { 
            position: relative; width: 80px; height: 80px; 
            background-size: 560px 320px;
            background-position: -160px -80px;
            background-color: #c0392b; border-radius: 50%; 
            border: 4px solid rgba(255,255,255,0.2); 
            box-shadow: 0 8px 0 #000; 
        }
        #action-btn:active { box-shadow: 0 4px 0 #000; transform: translateY(4px); }

    </style>
</head>
<body>

    <div id="game-viewport">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD JUEGO -->
        <div id="hud" style="display:none;">
            <div id="p1-score" class="score-box">P1: 0</div>
            <div id="p2-score" class="score-box">P2: 0</div>
            <div id="p3-score" class="score-box" style="display:none;">P3: 0</div>
            <div id="p4-score" class="score-box" style="display:none;">P4: 0</div>
        </div>
        
        <!-- GAME OVER OVERLAY -->
        <div id="game-over-overlay" style="display:none;">
            <h1 id="winner-text" style="font-size: 40px; color: #f1c40f;">GANADOR P1</h1>
            <p style="color: white; margin-top:0;">Lleg贸 a 3 puntos</p>
            <button onclick="location.reload()" style="width: auto; padding: 10px 30px;">REINICIAR</button>
        </div>

        <!-- PANTALLA DE CARGA -->
        <div id="screen-loading" class="screen-layer">
            <h1 style="color:white;">CARGANDO...</h1>
        </div>

        <!-- PANTALLA 1: LOGIN -->
        <div id="screen-login" class="screen-layer" style="display:none;">
            <div class="panel">
                <h1>Bombardo!</h1>
                <div style="font-size:10px; margin-bottom:10px; color:#ccc;">Desarrollado por: Steven Arias</div>
                <input type="text" id="roomInput" placeholder="ID SALA" value="TEST" maxlength="6">
                <button id="btnConnect" onclick="connectToServer()">CONECTAR</button>
                <div id="login-log">Desconectado</div>
            </div>
        </div>

        <!-- PANTALLA 2: LOBBY -->
        <div id="screen-lobby" class="screen-layer" style="display:none;">
            <div class="panel">
                <h1 style="font-size:20px;">SALA DE ESPERA</h1>
                <div class="lobby-grid">
                    <div id="slot-1" class="player-slot p1">P1 (HOST)</div>
                    <div id="slot-2" class="player-slot p2">P2: ESPERANDO...</div>
                    <div id="slot-3" class="player-slot p3">P3: ESPERANDO...</div>
                    <div id="slot-4" class="player-slot p4">P4: ESPERANDO...</div>
                </div>
                
                <button id="btnStartGame" onclick="hostStartGame()" disabled style="display:none; background:#2ecc71;">INICIAR PARTIDA</button>
                <div style="font-size:10px; margin-top:10px; color:#aaa;" id="lobby-msg">Esperando al Host...</div>
            </div>
        </div>
    </div>

    <!-- CONTROLES TCTILES -->
    <div id="gamepad-area">
        <div class="d-pad">
            <div id="btn-up" class="gp-btn arrow-btn"></div>
            <div id="btn-down" class="gp-btn arrow-btn"></div>
            <div id="btn-left" class="gp-btn arrow-btn"></div>
            <div id="btn-right" class="gp-btn arrow-btn"></div>
        </div>
        <div id="action-wrapper">
            <div id="action-btn" class="gp-btn"></div>
        </div>
    </div>

<script>
// --- CONFIGURACIN ---
const CONFIG = { 
    TILE: 32, COLS: 15, ROWS: 11, 
    WIDTH: 480, HEIGHT: 352, 
    SPEED: 2, 
    BRICK_DENSITY: 0.6, 
    BOMB_RANGE: 2, MAX_BOMBS: 2,
    WIN_SCORE: 3 // Puntos para ganar
};

const SPRITES = {
    WALL_SOLID: {x:0, y:0}, WALL_BRICK: {x:1, y:0}, FLOOR: {x:0, y:1}, 
    BOMB_IDLE: [{x:0, y:2}, {x:1, y:2}], 
    EXPLOSION_CENTER: {x:2, y:2}, EXPLOSION_MID: {x:0, y:3}, EXPLOSION_END: {x:1, y:3}, 
    CHAR: {
        IDLE_DOWN: [{x:3, y:0}], WALK_DOWN: [{x:4, y:0}, {x:3, y:0}, {x:5, y:0}, {x:3, y:0}], 
        IDLE_SIDE: [{x:6, y:0}], WALK_SIDE: [{x:3, y:1}, {x:4, y:1}, {x:5, y:1}, {x:6, y:1}], 
        IDLE_UP: [{x:3, y:2}], WALK_UP: [{x:4, y:2}, {x:3, y:2}, {x:5, y:2}, {x:3, y:2}], 
        DIE: [{x:6, y:2}, {x:3, y:3}, {x:4, y:3}, {x:5, y:3}]  
    }
};

// --- CARGA DE RECURSOS ---
const assets = { spritesheet: new Image(), loaded: false };

function loadAssets() {
    assets.spritesheet.src = 'sprites.png';
    assets.spritesheet.onload = () => { 
        assets.loaded = true; 
        console.log("Sprites cargados correctamente.");
        showLoginScreen(); 
    };
    assets.spritesheet.onerror = () => {
        console.warn("No se encontr贸 sprites.png. Usando modo debug.");
        assets.loaded = false;
        showLoginScreen();
    };
}

function showLoginScreen() {
    document.getElementById('screen-loading').style.display = 'none';
    document.getElementById('screen-login').style.display = 'flex';
    init(); 
}

// --- ESTADO ---
let mapGrid = [];
let bombs = []; 
let explosions = []; 
const TILE_TYPE = { EMPTY: 0, WALL: 1, BRICK: 2, BOMB: 3 };

const state = {
    status: 'LOGIN', // LOGIN, LOBBY, GAME
    input: { x: 0, y: 0, active: false },
    localPlayer: null,
    players: {}, 
    frame: 0,
    scores: { 1:0, 2:0, 3:0, 4:0 },
    processingDeath: false,
    winner: null
};

// --- RED ---
class Net {
    constructor() { this.ws=null; this.id=0; this.peers={}; }
    
    connect(room) {
        log("Conectando...");
        this.ws = new WebSocket('wss://bomber-server.onrender.com');
        this.ws.onopen = () => this.ws.send(JSON.stringify({type:'join', room:room}));
        this.ws.onmessage = e => this.handle(JSON.parse(e.data));
        this.ws.onerror = () => log("Error WS");
    }

    async handle(m) {
        switch(m.type) {
            case 'id': 
                this.id = m.id; 
                enterLobby(m.id); 
                break;
            case 'peer_connected': 
                this.initRTC(m.id, true); 
                break;
            case 'offer': 
                if(!this.peers[m.origin]) this.initRTC(m.origin, false);
                await this.peers[m.origin].rtc.setRemoteDescription(m.sdp);
                setTimeout(async()=>{
                    const a=await this.peers[m.origin].rtc.createAnswer();
                    await this.peers[m.origin].rtc.setLocalDescription(a);
                    this.sig({type:'answer', sdp:a, target:m.origin});
                }, 500);
                break;
            case 'answer': 
                if(this.peers[m.origin]) await this.peers[m.origin].rtc.setRemoteDescription(m.sdp); 
                break;
            case 'candidate': 
                if(this.peers[m.origin]) await this.peers[m.origin].rtc.addIceCandidate(m.candidate); 
                break;
        }
    }

    sig(d) { if(this.ws) this.ws.send(JSON.stringify(d)); }

    initRTC(peerId, offerer) {
        const rtc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        this.peers[peerId] = { rtc: rtc, ch: null };
        
        rtc.onicecandidate = e => { 
            if(e.candidate) this.sig({type:'candidate', candidate:e.candidate, target:peerId}); 
        };
        
        rtc.onconnectionstatechange = () => { 
            if(rtc.connectionState==='connected') updateLobbyUI(peerId, true);
            if(rtc.connectionState==='disconnected') updateLobbyUI(peerId, false);
        };
        
        if(offerer) {
            const ch = rtc.createDataChannel("game", {ordered:false, maxRetransmits:0});
            this.peers[peerId].ch = ch;
            this.setupCh(ch, peerId);
            rtc.createOffer().then(o => { 
                rtc.setLocalDescription(o); 
                this.sig({type:'offer', sdp:o, target:peerId}); 
            });
        } else {
            rtc.ondatachannel = e => { 
                this.peers[peerId].ch = e.channel; 
                this.setupCh(e.channel, peerId); 
            };
        }
    }

    setupCh(ch, peerId) { 
        ch.onmessage = e => onNetData(JSON.parse(e.data), peerId); 
        ch.onopen = () => {
            updateLobbyUI(peerId, true);
            if(this.id === 1) this.send({ t:'lobby_sync', players: Object.keys(this.peers).map(Number).concat([1]) });
        };
    }

    send(d) { 
        const msg = JSON.stringify(d);
        for(let pid in this.peers) {
            const p = this.peers[pid];
            if(p.ch && p.ch.readyState==='open') p.ch.send(msg);
        }
    }
}

// --- JUEGO (CLASES) ---
class Player {
    constructor(id, col, row, colorTint) {
        this.id = id; this.tint = colorTint;
        this.spawnX = col * CONFIG.TILE; this.spawnY = row * CONFIG.TILE;
        this.activeBombs = 0;
        this.sentIdlePacket = true; // Control para no floodear red al estar quieto
        this.reset();
    }
    reset() {
        this.x = this.spawnX; this.y = this.spawnY;
        this.targetX = this.x; this.targetY = this.y;
        this.isMoving = false; this.isDead = false;
        this.animState = 'IDLE_DOWN'; this.facingLeft = false;
        this.deadTimer = 0; this.activeBombs = 0;
        this.sentIdlePacket = true;
    }
    die() { 
        if(this.isDead) return; 
        this.isDead = true; 
        this.animState = 'DIE'; 
        this.deadTimer = 90; // 1.5 segundos muerte
    }
    update() {
        if (this.isDead) {
            if (this.deadTimer > 0) this.deadTimer--;
            else if (this.deadTimer === 0) {
                this.deadTimer = -1;
                this.reset(); 
                if(this.id === net.id) net.send({ t:'respawn', id:this.id });
            }
            return;
        }

        if (this.isMoving) {
            // Local visual smoothing
            if (this.id === net.id) {
                if (this.targetY > this.y) this.animState = 'WALK_DOWN';
                else if (this.targetY < this.y) this.animState = 'WALK_UP';
                else if (this.targetX > this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = false; }
                else if (this.targetX < this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = true; }
            }
            
            if (this.x < this.targetX) this.x += CONFIG.SPEED;
            if (this.x > this.targetX) this.x -= CONFIG.SPEED;
            if (this.y < this.targetY) this.y += CONFIG.SPEED;
            if (this.y > this.targetY) this.y -= CONFIG.SPEED;

            if (this.x === this.targetX && this.y === this.targetY) {
                this.isMoving = false;
                this.checkInput();
            }
        } else {
            // Idle states
            if (this.id === net.id) {
                if (this.animState === 'WALK_DOWN') this.animState = 'IDLE_DOWN';
                if (this.animState === 'WALK_UP') this.animState = 'IDLE_UP';
                if (this.animState === 'WALK_SIDE') this.animState = 'IDLE_SIDE';
            }
            this.checkInput();
        }
    }
    checkInput() {
        if (this.id !== net.id) return; 
        if (state.winner) return;

        if (state.input.active) {
            let col = Math.round(this.x / CONFIG.TILE);
            let row = Math.round(this.y / CONFIG.TILE);
            let nextCol = col + state.input.x;
            let nextRow = row + state.input.y;
            if (nextCol < 0 || nextCol >= CONFIG.COLS || nextRow < 0 || nextRow >= CONFIG.ROWS) return;
            if (mapGrid[nextRow][nextCol] !== TILE_TYPE.EMPTY) return; 
            const bombAtDest = bombs.find(b => b.col === nextCol && b.row === nextRow);
            if (bombAtDest) return;
            
            this.targetX = nextCol * CONFIG.TILE;
            this.targetY = nextRow * CONFIG.TILE;
            this.isMoving = true;
            this.sentIdlePacket = false; // Nos movemos, as铆 que necesitaremos enviar Idle luego

            // Determinar animaci贸n futura
            let nextAnim = this.animState;
            let facing = this.facingLeft;
            if(state.input.y > 0) nextAnim = 'WALK_DOWN';
            else if(state.input.y < 0) nextAnim = 'WALK_UP';
            else if(state.input.x > 0) { nextAnim = 'WALK_SIDE'; facing = false; }
            else if(state.input.x < 0) { nextAnim = 'WALK_SIDE'; facing = true; }
            
            // ENVIAR MOVIMIENTO
            net.send({ 
                t:'m', 
                tx:this.targetX, ty:this.targetY, 
                x:this.x, y:this.y, 
                id:this.id,
                a: nextAnim, 
                f: facing    
            });
        } else {
            // FIX IDLE SYNC: Si acabamos de dejar de movernos y no hemos enviado paquete
            if (!this.sentIdlePacket) {
                // Calcular estado idle
                let idleAnim = this.animState;
                if(idleAnim.startsWith('WALK_DOWN')) idleAnim = 'IDLE_DOWN';
                if(idleAnim.startsWith('WALK_UP')) idleAnim = 'IDLE_UP';
                if(idleAnim.startsWith('WALK_SIDE')) idleAnim = 'IDLE_SIDE';
                
                this.animState = idleAnim;

                // Enviar paquete IDLE una sola vez
                net.send({ 
                    t:'m', 
                    tx:this.x, ty:this.y, 
                    x:this.x, y:this.y, 
                    id:this.id,
                    a: idleAnim, 
                    f: this.facingLeft    
                });
                this.sentIdlePacket = true;
            }
        }
    }
    placeBomb() {
        if (this.isDead || this.activeBombs >= CONFIG.MAX_BOMBS || state.winner) return;
        const c = Math.round(this.x / CONFIG.TILE);
        const r = Math.round(this.y / CONFIG.TILE);
        if (mapGrid[r][c] === TILE_TYPE.BOMB) return; 
        if (bombs.some(b => b.col === c && b.row === r)) return;
        createBomb(c, r, this.id);
        this.activeBombs++;
        net.send({ t:'b', c:c, r:r, oid:this.id });
    }
    draw(ctx) {
        if (this.isDead && this.deadTimer <= 0) return; 
        
        const animData = SPRITES.CHAR[this.animState];
        let frameIdx = 0;
        if (this.animState === 'DIE') {
            const total = animData.length;
            frameIdx = Math.min(Math.floor((1 - (this.deadTimer / 90)) * total), total - 1);
        } else frameIdx = Math.floor(state.frame / 10) % animData.length;
        
        const coords = animData[frameIdx];
        const drawX = this.x; const drawY = this.y - 8; 
        
        ctx.save();
        if (this.facingLeft) {
            ctx.translate(drawX + CONFIG.TILE, drawY);
            ctx.scale(-1, 1);
            drawSprite(ctx, coords, 0, 0);
        } else drawSprite(ctx, coords, drawX, drawY);
        ctx.restore();

        if (!this.isDead) {
            ctx.fillStyle = this.tint;
            ctx.beginPath();
            ctx.moveTo(this.x + 16, this.y - 12);
            ctx.lineTo(this.x + 12, this.y - 18);
            ctx.lineTo(this.x + 20, this.y - 18);
            ctx.fill();
        }
    }
}

class Bomb {
    constructor(col, row, ownerId) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 180; this.exploded = false;
    }
    update() { if(this.exploded) return true; this.timer--; return this.timer <= 0; }
    detonate() { this.timer = 0; this.exploded = true; }
    draw(ctx) {
        const frames = SPRITES.BOMB_IDLE;
        const speed = this.timer < 60 ? 5 : 15;
        const idx = Math.floor(state.frame / speed) % frames.length;
        drawSprite(ctx, frames[idx], this.col*CONFIG.TILE, this.row*CONFIG.TILE);
    }
}

class Explosion {
    constructor(col, row, ownerId, type) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 30; this.sprite = type === 'center' ? SPRITES.EXPLOSION_CENTER : SPRITES.EXPLOSION_MID;
    }
    update() { 
        this.timer--; 
        checkPlayerHit(this.col, this.row, state.localPlayer, this.ownerId);
        for(let pid in state.players) checkPlayerHit(this.col, this.row, state.players[pid], this.ownerId);
        return this.timer <= 0; 
    }
    draw(ctx) { if (Math.floor(this.timer/3)%2===0) drawSprite(ctx, this.sprite, this.col*CONFIG.TILE, this.row*CONFIG.TILE); }
}

function checkPlayerHit(c, r, player, killerId) {
    if (!player || player.isDead || state.winner) return;
    if (Math.round(player.x / CONFIG.TILE) === c && Math.round(player.y / CONFIG.TILE) === r) {
        player.die(); 
        updateScore(killerId, player.id);
    }
}

function updateScore(killerId, victimId) {
    if (state.processingDeath || state.winner) return;
    state.processingDeath = true; 
    setTimeout(() => state.processingDeath = false, 500);
    
    if (killerId === victimId) {
        state.scores[killerId] = Math.max(0, (state.scores[killerId] || 0) - 1);
    } else {
        if(!state.scores[killerId]) state.scores[killerId] = 0;
        state.scores[killerId]++;
    }
    updateHUD();
    checkWinCondition();
}

function checkWinCondition() {
    for(let pid in state.scores) {
        if(state.scores[pid] >= CONFIG.WIN_SCORE) {
            state.winner = pid;
            document.getElementById('game-over-overlay').style.display = 'flex';
            document.getElementById('winner-text').innerText = `GANADOR P${pid}`;
        }
    }
}

function updateHUD() {
    for(let i=1; i<=4; i++) {
        const el = document.getElementById(`p${i}-score`);
        if(el) el.innerText = `P${i}: ${state.scores[i] || 0}`;
    }
}

function drawSprite(ctx, coord, x, y) {
    if (assets.loaded && coord) ctx.drawImage(assets.spritesheet, coord.x*32, coord.y*32, 32, 32, x, y, 32, 32);
    else { ctx.fillStyle = "#ff00ff"; ctx.fillRect(x, y, 32, 32); }
}

// --- SISTEMA & FLUJO ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const net = new Net();

window.onload = loadAssets;

function init() {
    ctx.imageSmoothingEnabled = false;
    window.addEventListener('resize', resizeViewport);
    setupInputs();
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('gamepad-area').style.display = 'flex';
    }
    resizeViewport();
    generateMap(); 
    requestAnimationFrame(gameLoop);
}

function connectToServer() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    document.getElementById('btnConnect').disabled = true;
    document.getElementById('btnConnect').innerText = "...";
    net.connect(room.toUpperCase());
}

function enterLobby(myId) {
    state.status = 'LOBBY';
    document.getElementById('screen-login').style.display = 'none';
    document.getElementById('screen-lobby').style.display = 'flex';
    updateLobbyUI(myId, true);
    if(myId === 1) {
        document.getElementById('btnStartGame').style.display = 'block';
        document.getElementById('btnStartGame').disabled = false;
        document.getElementById('lobby-msg').innerText = "Eres el HOST. Espera jugadores y dale a Iniciar.";
    }
}

function updateLobbyUI(id, connected) {
    const slot = document.getElementById(`slot-${id}`);
    if(slot) {
        if(connected) { slot.classList.add('active'); slot.innerText = `P${id} (LISTO)`; }
        else { slot.classList.remove('active'); slot.innerText = `P${id}: ...`; }
    }
}

function hostStartGame() {
    if(net.id !== 1) return;
    generateMap();
    net.send({ t:'start', grid:mapGrid });
    beginGameLoop();
}

function beginGameLoop() {
    state.status = 'GAME';
    document.getElementById('screen-lobby').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    for(let i=1; i<=4; i++) document.getElementById(`p${i}-score`).style.display = 'block';
    
    const info = getSpawnInfo(net.id);
    state.localPlayer = new Player(net.id, info.x, info.y, info.c);
}

function onNetData(d, peerId) {
    const targetId = d.id || peerId;
    if (state.status === 'LOBBY') {
        if(d.t === 'start') {
            mapGrid = d.grid;
            beginGameLoop();
        }
        if(d.t === 'lobby_sync') {
             d.players.forEach(pid => updateLobbyUI(pid, true));
        }
        return;
    }
    if (state.status === 'GAME') {
        let p = state.players[targetId];
        if (d.t === 'm') {
            if(!p) {
                const info = getSpawnInfo(targetId);
                state.players[targetId] = new Player(targetId, info.x, info.y, info.c);
                p = state.players[targetId];
            }
            p.x = d.x; p.y = d.y;
            p.targetX = d.tx; p.targetY = d.ty;
            p.isMoving = true;
            
            // SYNC VISUAL: Aplicar animaci贸n recibida por red
            if(d.a) p.animState = d.a;
            if(typeof d.f !== 'undefined') p.facingLeft = d.f;
        }
        if (d.t === 'b') createBomb(d.c, d.r, d.oid);
        if (d.t === 'map') mapGrid = d.grid;
        if (d.t === 'respawn' && p) p.reset();
    }
}

// --- HELPERS ---
function getSpawnInfo(id) {
    const colors = { 1: '#3498db', 2: '#e74c3c', 3: '#2ecc71', 4: '#f1c40f' };
    const x = (id===1 || id===4) ? 1 : CONFIG.COLS - 2;
    const y = (id===1 || id===3) ? 1 : CONFIG.ROWS - 2;
    return { c: colors[id] || '#fff', x: x, y: y };
}

function generateMap() {
    mapGrid = [];
    const safeZone = (c, r) => (c<=2 && r<=2) || (c>=CONFIG.COLS-3 && r>=CONFIG.ROWS-3) || (c>=CONFIG.COLS-3 && r<=2) || (c<=2 && r>=CONFIG.ROWS-3);
    for(let r=0; r<CONFIG.ROWS; r++) {
        let row = [];
        for(let c=0; c<CONFIG.COLS; c++) {
            if (r===0 || c===0 || r===CONFIG.ROWS-1 || c===CONFIG.COLS-1 || (r%2===0 && c%2===0)) row.push(TILE_TYPE.WALL);
            else if (!safeZone(c,r) && Math.random() < CONFIG.BRICK_DENSITY) row.push(TILE_TYPE.BRICK);
            else row.push(TILE_TYPE.EMPTY);
        }
        mapGrid.push(row);
    }
}

function createBomb(c, r, ownerId) { mapGrid[r][c] = TILE_TYPE.BOMB; bombs.push(new Bomb(c, r, ownerId)); }
function explode(bomb) {
    const centerC = bomb.col; const centerR = bomb.row; const ownerId = bomb.ownerId;
    if (state.localPlayer && state.localPlayer.id === ownerId) state.localPlayer.activeBombs--;
    else if (state.players[ownerId]) state.players[ownerId].activeBombs--;
    mapGrid[centerR][centerC] = TILE_TYPE.EMPTY;
    explosions.push(new Explosion(centerC, centerR, ownerId, 'center')); 
    const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; 
    dirs.forEach(dir => {
        for(let i=1; i<=CONFIG.BOMB_RANGE; i++) {
            const nc = centerC + (dir.x * i); const nr = centerR + (dir.y * i);
            if(nc<0 || nr<0 || nc>=CONFIG.COLS || nr>=CONFIG.ROWS) break;
            const type = mapGrid[nr][nc];
            if (type === TILE_TYPE.WALL) break; 
            if (type === TILE_TYPE.BRICK) { mapGrid[nr][nc] = TILE_TYPE.EMPTY; explosions.push(new Explosion(nc, nr, ownerId)); break; } 
            else if (type === TILE_TYPE.BOMB) {
                const chained = bombs.find(b => b.col === nc && b.row === nr && !b.exploded);
                if (chained) chained.detonate();
                explosions.push(new Explosion(nc, nr, ownerId));
            } else explosions.push(new Explosion(nc, nr, ownerId));
        }
    });
}

function resizeViewport() {
    const controlsH = document.getElementById('gamepad-area').style.display === 'flex' ? 240 : 0;
    const availW = window.innerWidth;
    const availH = window.innerHeight - controlsH;
    if (availH < 0) return; 
    const scale = Math.min(availW / CONFIG.WIDTH, availH / CONFIG.HEIGHT);
    
    const vp = document.getElementById('game-viewport');
    vp.style.width = (CONFIG.WIDTH * scale) + "px";
    vp.style.height = (CONFIG.HEIGHT * scale) + "px";
    
    canvas.width = CONFIG.WIDTH; 
    canvas.height = CONFIG.HEIGHT;
    ctx.imageSmoothingEnabled = false;
}

function gameLoop() { state.frame++; update(); draw(); requestAnimationFrame(gameLoop); }
function update() {
    if (state.localPlayer) state.localPlayer.update();
    for(let pid in state.players) {
        state.players[pid].update(); 
    }
    for (let i = bombs.length - 1; i >= 0; i--) { const b = bombs[i]; if (b.update()) { explode(b); bombs.splice(i, 1); } }
    for (let i = explosions.length - 1; i >= 0; i--) { if (explosions[i].update()) explosions.splice(i, 1); }
}
function draw() {
    ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<CONFIG.ROWS; r++) {
        for(let c=0; c<CONFIG.COLS; c++) {
            const x = c*CONFIG.TILE; const y = r*CONFIG.TILE;
            const cell = mapGrid[r][c];
            drawSprite(ctx, SPRITES.FLOOR, x, y);
            if (cell === TILE_TYPE.WALL) drawSprite(ctx, SPRITES.WALL_SOLID, x, y);
            else if (cell === TILE_TYPE.BRICK) drawSprite(ctx, SPRITES.WALL_BRICK, x, y);
        }
    }
    bombs.forEach(b => b.draw(ctx));
    explosions.forEach(e => e.draw(ctx));
    const allPlayers = [];
    if(state.localPlayer) allPlayers.push(state.localPlayer);
    for(let pid in state.players) allPlayers.push(state.players[pid]);
    allPlayers.sort((a,b) => a.y - b.y);
    allPlayers.forEach(p => p.draw(ctx));
}

function setupInputs() {
    const setDir = (x, y) => { state.input.x = x; state.input.y = y; state.input.active = (x!==0 || y!==0); };
    window.onkeydown = e => {
        if(e.repeat) return;
        if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
        if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
        if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
        if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
        if(e.code==='Space') { if(state.localPlayer) state.localPlayer.placeBomb(); }
    };
    window.onkeyup = e => { if(['ArrowUp','w','ArrowDown','s','ArrowLeft','a','ArrowRight','d'].includes(e.key)) setDir(0,0); };
    const btnAct = document.getElementById('action-btn');
    btnAct.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        if(state.localPlayer) state.localPlayer.placeBomb(); 
    }, {passive:false});
    bindTouch('btn-up',0,-1); bindTouch('btn-down',0,1); bindTouch('btn-left',-1,0); bindTouch('btn-right',1,0);
}
function bindTouch(id, x, y) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        state.input.x=x; state.input.y=y; state.input.active=true; 
        el.style.opacity = "0.6";
    }, {passive:false});
    el.addEventListener('touchend', (e) => { 
        e.preventDefault(); 
        state.input.active=false; 
        el.style.opacity = "1";
    });
}
function log(t) { if(document.getElementById('login-log')) document.getElementById('login-log').innerText = t; }
</script>
</body>
</html>