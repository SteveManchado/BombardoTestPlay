<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bombardo v4.6</title>
    <style>
        /* --- LAYOUT PRINCIPAL --- */
        body {
            margin: 0; padding: 0; background-color: #111;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden; touch-action: none; font-family: 'Courier New', monospace;
            user-select: none; -webkit-user-select: none;
        }

        /* HUD JUEGO (BARRA SUPERIOR) */
        #hud { 
            display: none; /* Se activa con JS display:flex */
            width: 100%;
            max-width: 480px; /* Mismo ancho que el juego */
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            margin-bottom: 4px; /* SeparaciÃ³n del canvas */
            background-color: #1a1a1a;
            box-sizing: border-box;
            border-bottom: 2px solid #333;
        }

        .score-box { 
            background: #2c3e50; 
            padding: 6px 2px; 
            color: white; 
            font-weight: bold; 
            border: 1px solid #444; 
            font-size: 10px; /* Ajustado para nombres de 5 letras */
            text-shadow: 1px 1px 0 #000; 
            margin: 0 2px;
            text-align: center;
            flex: 1; /* Repartir espacio equitativamente */
            white-space: nowrap;
            overflow: hidden;
            border-radius: 4px;
        }
        
        /* Caja del Timer fija para que no baile */
        #timer-box { 
            color: #fff; 
            border: 1px solid #f1c40f; 
            flex: 0 0 50px; /* Ancho fijo */
            background: #222;
        }

        /* CONTENEDOR DEL JUEGO */
        #game-viewport {
            position: relative; background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            width: 480px; height: 352px; /* 15x11 tiles de 32px */
            flex-shrink: 1; display: flex; justify-content: center; align-items: center;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        /* FIX PIXEL ART */
        canvas { 
            display: block; width: 100%; height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* --- UI --- */
        .screen-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.9); z-index: 100;
        }
        
        .panel { 
            background: #2c3e50; border: 4px solid #fff; padding: 20px; 
            text-align: center; min-width: 280px; box-sizing: border-box; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        h1 { color: #f1c40f; margin: 0 0 15px 0; font-size: 24px; text-shadow: 2px 2px #c0392b; }
        
        input { 
            padding: 10px; background: #000; color: #fff; border: 2px solid #555; 
            text-align: center; display: block; margin: 0 auto 15px auto; 
            width: 150px; text-transform: uppercase; font-size: 16px; 
        }
        
        button { 
            padding: 12px 20px; background: #e74c3c; color: white; border: 2px solid #fff; 
            font-weight: bold; width: 100%; font-size: 16px; cursor: pointer; margin-top: 5px; 
        }
        button:active { transform: scale(0.95); background: #c0392b; }
        button:disabled { background: #555; color: #888; border-color: #555; cursor: not-allowed; transform: none; }
        
        #btnReady { background: #2ecc71; margin-top: 10px; }
        #btnReady.is-ready { background: #7f8c8d; }

        #login-log { font-size: 11px; color: #aaa; margin-top: 10px; min-height: 14px; }

        /* LOBBY */
        .lobby-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .player-slot { 
            background: #333; padding: 10px; border: 2px solid #555; 
            color: #777; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 0 #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative;
        }
        .player-slot.active { border-color: #fff; color: #fff; }
        .ready-badge {
            position: absolute; bottom: 2px; right: 2px; font-size: 14px; color: #2ecc71;
            display: none; text-shadow: 0 0 2px #000;
        }
        .player-slot.ready .ready-badge { display: block; }
        
        /* COLORES DE UI ACTUALIZADOS - Paleta de Jugadores */
        .player-slot.p1.active { background: #ac3232; } 
        .player-slot.p2.active { background: #3498db; } 
        .player-slot.p3.active { background: #f1c40f; } 
        .player-slot.p4.active { background: #9b59b6; } 

        /* PERFIL */
        #profile-editor {
            background: #34495e; padding: 10px; margin-bottom: 15px; border: 1px dashed #7f8c8d;
            transition: opacity 0.3s;
        }
        #profile-editor.locked { opacity: 0.5; pointer-events: none; }

        .color-palette { display: flex; justify-content: center; gap: 5px; margin-top: 5px; }
        .color-btn { width: 24px; height: 24px; border: 2px solid #000; cursor: pointer; transition: transform 0.1s; }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.selected { border-color: #fff; box-shadow: 0 0 5px #fff; transform: scale(1.2); z-index: 2; }
        .color-btn.taken { opacity: 0.2; cursor: not-allowed; border-color: #555; transform: scale(0.8); }

        /* OVERLAY */
        #game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
        }

        /* CONTROLES */
        #gamepad-area {
            display: none; width: 100%; min-height: 240px; 
            background: #1a1a1a; border-top: 4px solid #333;
            flex-direction: row; justify-content: space-between; align-items: flex-start;
            padding: 20px 30px; padding-bottom: max(20px, env(safe-area-inset-bottom));
            box-sizing: border-box; flex-shrink: 0;
        }
        .gp-btn { 
            position: absolute; background-image: url('sprites.png'); 
            background-repeat: no-repeat; image-rendering: pixelated; 
        }
        .gp-btn:active { filter: brightness(1.2); transform: scale(0.95); }
        .d-pad { position: relative; width: 180px; height: 180px; }
        .arrow-btn { width: 64px; height: 64px; background-size: 448px 256px; background-position: -128px -192px; }
        #btn-up { left: 58px; top: 0; } 
        #btn-down { left: 58px; bottom: 0; transform: rotate(180deg); }
        #btn-left { left: 0; top: 58px; transform: rotate(-90deg); } 
        #btn-right { right: 0; top: 58px; transform: rotate(90deg); }
        #action-wrapper { position: relative; width: 120px; height: 120px; display: flex; justify-content: center; align-items: center; margin-top: 20px; }
        #action-btn { position: relative; width: 80px; height: 80px; background-size: 560px 320px; background-position: -160px -80px; background-color: #c0392b; border-radius: 50%; border: 4px solid rgba(255,255,255,0.2); box-shadow: 0 8px 0 #000; }
        #action-btn:active { box-shadow: 0 4px 0 #000; transform: translateY(4px); }

    </style>
</head>
<body>

    <!-- HUD JUEGO (Mellado y reubicado encima del viewport) -->
    <div id="hud" style="display:none;">
        <div id="timer-box" class="score-box">120</div>
        <div id="p1-score" class="score-box">P1: 0</div>
        <div id="p2-score" class="score-box">P2: 0</div>
        <div id="p3-score" class="score-box" style="display:none;">P3: 0</div>
        <div id="p4-score" class="score-box" style="display:none;">P4: 0</div>
    </div>

    <div id="game-viewport">
        <canvas id="gameCanvas"></canvas>
        
        <div id="game-over-overlay" style="display:none;">
            <h1 id="winner-text" style="font-size: 40px; color: #f1c40f;">GANADOR</h1>
            <p id="winner-reason" style="color: white; margin-top:0;">...</p>
            <button onclick="location.reload()" style="width: auto; padding: 10px 30px;">REINICIAR</button>
        </div>

        <div id="screen-loading" class="screen-layer">
            <h1 style="color:white;">CARGANDO...</h1>
        </div>

        <div id="screen-login" class="screen-layer" style="display:none;">
            <div class="panel">
                <h1>Bombardo!ðŸ’£(v4.6)</h1>
                <div style="font-size:10px; margin-bottom:10px; color:#ccc;">Desarrollado por: Steven Arias</div>
                <input type="text" id="roomInput" placeholder="ID SALA" value="TEST" maxlength="6">
                <button id="btnConnect" onclick="connectToServer()">CONECTAR</button>
                <div id="login-log">Desconectado</div>
            </div>
        </div>

        <div id="screen-lobby" class="screen-layer" style="display:none;">
            <div class="panel">
                <h1 style="font-size:20px; margin-bottom: 5px;">SALA DE ESPERA</h1>
                
                <div id="profile-editor">
                    <div style="font-size: 10px; color: #ccc; margin-bottom: 5px;">MI PERFIL</div>
                    <input type="text" id="my-name-input" placeholder="NOMBRE" maxlength="5" style="width: 100px; padding: 5px; margin-bottom: 5px;">
                    <div class="color-palette" id="color-palette"></div>
                </div>

                <button id="btnReady" onclick="toggleReady()">Â¡ESTOY LISTO!</button>

                <div class="lobby-grid" style="margin-top:15px;">
                    <div id="slot-1" class="player-slot">P1 (HOST)<span class="ready-badge">âœ”</span></div>
                    <div id="slot-2" class="player-slot">P2: ...<span class="ready-badge">âœ”</span></div>
                    <div id="slot-3" class="player-slot">P3: ...<span class="ready-badge">âœ”</span></div>
                    <div id="slot-4" class="player-slot">P4: ...<span class="ready-badge">âœ”</span></div>
                </div>
                
                <button id="btnStartGame" onclick="hostStartGame()" disabled style="display:none; background:#f1c40f; color:#000;">INICIAR PARTIDA</button>
                <div style="font-size:10px; margin-top:10px; color:#aaa;" id="lobby-msg">Esperando al Host...</div>
            </div>
        </div>
    </div>

    <div id="gamepad-area">
        <div class="d-pad">
            <div id="btn-up" class="gp-btn arrow-btn"></div>
            <div id="btn-down" class="gp-btn arrow-btn"></div>
            <div id="btn-left" class="gp-btn arrow-btn"></div>
            <div id="btn-right" class="gp-btn arrow-btn"></div>
        </div>
        <div id="action-wrapper">
            <div id="action-btn" class="gp-btn"></div>
        </div>
    </div>

<script>
// --- CONFIGURACIÃ“N ---
const CONFIG = { 
    TILE: 32, COLS: 15, ROWS: 11, 
    WIDTH: 480, HEIGHT: 352, 
    SPEED: 2, 
    BRICK_DENSITY: 0.6, 
    BOMB_RANGE: 2, MAX_BOMBS: 2,
    WIN_SCORE: 3, 
    ROUND_TIME: 120
};

// Coordenadas Sprites
const SPRITES = {
    WALL_SOLID: {x:0, y:0}, WALL_BRICK: {x:1, y:0}, 
    FLOOR: {x:0, y:1}, // <-- COORDENADA AJUSTADA SEGÃšN SOLICITUD
    BOMB_IDLE: [{x:0, y:2}, {x:1, y:2}], 
    EXPLOSION_CENTER: {x:2, y:2}, EXPLOSION_MID: {x:0, y:3}, EXPLOSION_END: {x:1, y:3}, 
    CHAR: {
        IDLE_DOWN: [{x:3, y:0}], WALK_DOWN: [{x:4, y:0}, {x:3, y:0}, {x:5, y:0}], 
        IDLE_SIDE: [{x:6, y:0}], WALK_SIDE: [{x:3, y:1}, {x:4, y:1}, {x:5, y:1}], 
        IDLE_UP: [{x:3, y:2}], WALK_UP: [{x:4, y:2}, {x:3, y:2}, {x:5, y:2}], 
        DIE: [{x:6, y:2}, {x:3, y:3}, {x:4, y:3}, {x:5, y:3}]  
    }
};

// ConfiguraciÃ³n ICE ampliada para mejorar conectividad
const ICE_SERVERS = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
    ]
};

// Paleta de Colores
const PALETTE = [
    { name: 'Red', hex: '#ac3232', filter: 'none' }, // Original
    { name: 'Blue', hex: '#3498db', filter: 'hue-rotate(210deg) brightness(1.2)' },
    { name: 'Green', hex: '#2ecc71', filter: 'hue-rotate(120deg) brightness(1.2)' },
    { name: 'Yellow', hex: '#f1c40f', filter: 'hue-rotate(60deg) brightness(1.5)' },
    { name: 'Purple', hex: '#9b59b6', filter: 'hue-rotate(290deg) brightness(1.1)' },
    { name: 'Cyan', hex: '#00cec9', filter: 'hue-rotate(180deg) brightness(1.3)' }
];

// --- CARGA Y CACHÃ‰ DE ASSETS ---
const assets = { 
    spritesheet: new Image(), 
    coloredSheets: [], 
    loaded: false 
};

function loadAssets() {
    assets.spritesheet.src = 'sprites.png';
    assets.spritesheet.onload = () => { 
        generateColoredSprites();
        assets.loaded = true; 
        console.log("Sprites y cachÃ© generados.");
        showLoginScreen(); 
    };
    assets.spritesheet.onerror = () => {
        console.warn("Error sprites.");
        assets.loaded = false;
        showLoginScreen();
    };
}

// CACHÃ‰ DE SPRITES
function generateColoredSprites() {
    PALETTE.forEach((pal, idx) => {
        const c = document.createElement('canvas');
        c.width = assets.spritesheet.width;
        c.height = assets.spritesheet.height;
        const ctx = c.getContext('2d');
        ctx.imageSmoothingEnabled = false; 
        if (pal.filter !== 'none') ctx.filter = pal.filter;
        ctx.drawImage(assets.spritesheet, 0, 0);
        assets.coloredSheets[idx] = c;
    });
}

function showLoginScreen() {
    document.getElementById('screen-loading').style.display = 'none';
    document.getElementById('screen-login').style.display = 'flex';
    init(); 
    initUI();
}

// --- ESTADO ---
let mapGrid = [];
let bombs = []; 
let explosions = []; 
const TILE_TYPE = { EMPTY: 0, WALL: 1, BRICK: 2, BOMB: 3 };

const state = {
    status: 'LOGIN', 
    input: { x: 0, y: 0, active: false },
    localPlayer: null,
    players: {}, 
    lobbyPlayers: {}, 
    frame: 0,
    scores: { 1:0, 2:0, 3:0, 4:0 },
    processingDeath: false,
    winner: null,
    timeLeft: CONFIG.ROUND_TIME
};

let myProfile = { name: '', colorIdx: 0, isReady: false };

function initUI() {
    const nameInput = document.getElementById('my-name-input');
    nameInput.replaceWith(nameInput.cloneNode(true));
    document.getElementById('my-name-input').addEventListener('input', (e) => {
        if(myProfile.isReady) return; 
        myProfile.name = e.target.value.toUpperCase();
        if(net.id) sendProfileUpdate(); 
    });
    updatePaletteUI();
}

function updatePaletteUI() {
    const takenColors = new Set();
    for (let pid in state.lobbyPlayers) {
        if (parseInt(pid) !== net.id) {
            takenColors.add(state.lobbyPlayers[pid].colorIdx);
        }
    }

    const container = document.getElementById('color-palette');
    container.innerHTML = '';
    
    PALETTE.forEach((col, idx) => {
        const d = document.createElement('div');
        d.className = 'color-btn';
        d.style.backgroundColor = col.hex;
        
        if (idx === myProfile.colorIdx) d.classList.add('selected');
        
        if (takenColors.has(idx)) {
            d.classList.add('taken');
        } else {
            d.onclick = () => {
                if(!myProfile.isReady) setLocalColor(idx);
            };
        }
        container.appendChild(d);
    });
}

function setLocalColor(idx) {
    for (let pid in state.lobbyPlayers) {
        if (parseInt(pid) !== net.id && state.lobbyPlayers[pid].colorIdx === idx) return;
    }
    myProfile.colorIdx = idx;
    updatePaletteUI();
    if(net.id) sendProfileUpdate();
}

function toggleReady() {
    if(!net.id) return;
    if(net.id === 1) return;

    myProfile.isReady = !myProfile.isReady;
    
    const btn = document.getElementById('btnReady');
    const editor = document.getElementById('profile-editor');
    
    if(myProfile.isReady) {
        btn.innerText = "CANCELAR / EDITAR";
        btn.classList.add('is-ready');
        editor.classList.add('locked');
        document.getElementById('my-name-input').disabled = true;
    } else {
        btn.innerText = "Â¡ESTOY LISTO!";
        btn.classList.remove('is-ready');
        editor.classList.remove('locked');
        document.getElementById('my-name-input').disabled = false;
    }
    
    sendProfileUpdate();
}

function sendProfileUpdate() {
    net.send({ 
        t: 'profile_update', 
        id: net.id, 
        name: myProfile.name || `P${net.id}`, 
        cIdx: myProfile.colorIdx,
        rdy: myProfile.isReady 
    });
    updateLobbyData(net.id, myProfile.name || `P${net.id}`, myProfile.colorIdx, myProfile.isReady);
}

function updateLobbyData(id, name, colorIdx, isReady) {
    state.lobbyPlayers[id] = { name: name, colorIdx: colorIdx, isReady: isReady };
    renderLobbySlots();
    updatePaletteUI();
    
    if(net.id === 1) {
        const btnStart = document.getElementById('btnStartGame');
        const others = Object.keys(state.lobbyPlayers).filter(pid => pid != 1);
        const allReady = others.length > 0 && others.every(pid => state.lobbyPlayers[pid].isReady);
        
        if(allReady || others.length === 0) {
            btnStart.disabled = false;
            btnStart.style.opacity = "1";
            btnStart.innerText = "INICIAR PARTIDA";
        } else {
            btnStart.disabled = true;
            btnStart.style.opacity = "0.5";
            btnStart.innerText = "ESPERANDO JUGADORES...";
        }
    }

    if(state.players[id]) {
        state.players[id].name = name;
        state.players[id].colorIdx = colorIdx;
    }
}

function renderLobbySlots() {
    for(let i=1; i<=4; i++) {
        const slot = document.getElementById(`slot-${i}`);
        const pData = state.lobbyPlayers[i];
        if (pData) {
            slot.classList.add('active');
            slot.innerText = `${pData.name} ${i===1?'(HOST)':''}`;
            const colorInfo = PALETTE[pData.colorIdx] || PALETTE[0];
            slot.style.backgroundColor = colorInfo.hex;
            slot.style.color = (pData.colorIdx === 3 || pData.colorIdx === 5) ? '#000' : '#fff';
            if(pData.isReady || i === 1) slot.classList.add('ready');
            else slot.classList.remove('ready');
        } else {
            slot.classList.remove('active');
            slot.classList.remove('ready');
            slot.style.backgroundColor = '#333';
            slot.style.color = '#777';
            slot.innerText = `P${i}: ...`;
        }
    }
    // Update Score colors and names
    for(let i=1; i<=4; i++) {
        const pData = state.lobbyPlayers[i];
        const el = document.getElementById(`p${i}-score`);
        if(pData) {
            el.innerText = `${pData.name}: ${state.scores[i] || 0}`;
            el.style.color = PALETTE[pData.colorIdx].hex;
        } else {
            el.style.display = 'none';
        }
    }
}

// --- RED ---
class Net {
    constructor() { this.ws=null; this.id=0; this.peers={}; }
    connect(room) {
        log("Conectando...");
        this.ws = new WebSocket('wss://bomber-server.onrender.com');
        this.ws.onopen = () => this.ws.send(JSON.stringify({type:'join', room:room}));
        this.ws.onmessage = e => this.handle(JSON.parse(e.data));
        this.ws.onerror = () => log("Error WS");
    }
    async handle(m) {
        switch(m.type) {
            case 'id': 
                this.id = m.id; 
                if(!myProfile.name) {
                    myProfile.name = `P${m.id}`;
                    document.getElementById('my-name-input').value = myProfile.name;
                }
                let startColor = (m.id - 1) % PALETTE.length;
                myProfile.colorIdx = startColor;
                if(m.id === 1) document.getElementById('btnReady').style.display = 'none';
                enterLobby(m.id); 
                break;
            case 'peer_connected': this.initRTC(m.id, true); break;
            case 'offer': 
                if(!this.peers[m.origin]) this.initRTC(m.origin, false);
                await this.peers[m.origin].rtc.setRemoteDescription(m.sdp);
                // Vaciar cola de candidatos pendientes si la hay
                if(this.peers[m.origin].pendingCandidates) {
                    for(let c of this.peers[m.origin].pendingCandidates) {
                        await this.peers[m.origin].rtc.addIceCandidate(c);
                    }
                    this.peers[m.origin].pendingCandidates = [];
                }
                
                setTimeout(async()=>{
                    const a=await this.peers[m.origin].rtc.createAnswer();
                    await this.peers[m.origin].rtc.setLocalDescription(a);
                    this.sig({type:'answer', sdp:a, target:m.origin});
                }, 500);
                break;
            case 'answer': 
                if(this.peers[m.origin]) await this.peers[m.origin].rtc.setRemoteDescription(m.sdp); 
                break;
            case 'candidate': 
                if(this.peers[m.origin]) {
                    const p = this.peers[m.origin];
                    // FIX: Cola de espera para candidatos tempraneros
                    if (p.rtc.remoteDescription) {
                        await p.rtc.addIceCandidate(m.candidate);
                    } else {
                        if (!p.pendingCandidates) p.pendingCandidates = [];
                        p.pendingCandidates.push(m.candidate);
                    }
                }
                break;
        }
    }
    sig(d) { if(this.ws) this.ws.send(JSON.stringify(d)); }
    initRTC(peerId, offerer) {
        const rtc = new RTCPeerConnection(ICE_SERVERS);
        this.peers[peerId] = { rtc: rtc, ch: null, pendingCandidates: [] };
        
        rtc.onicecandidate = e => { if(e.candidate) this.sig({type:'candidate', candidate:e.candidate, target:peerId}); };
        
        rtc.onconnectionstatechange = () => { 
            console.log(`ConexiÃ³n con P${peerId}: ${rtc.connectionState}`);
            if(rtc.connectionState==='disconnected' || rtc.connectionState === 'failed') {
                delete state.lobbyPlayers[peerId];
                renderLobbySlots();
                updatePaletteUI();
            }
        };
        
        if(offerer) {
            const ch = rtc.createDataChannel("game", {ordered:false, maxRetransmits:0});
            this.peers[peerId].ch = ch;
            this.setupCh(ch, peerId);
            rtc.createOffer().then(o => { rtc.setLocalDescription(o); this.sig({type:'offer', sdp:o, target:peerId}); });
        } else {
            rtc.ondatachannel = e => { this.peers[peerId].ch = e.channel; this.setupCh(e.channel, peerId); };
        }
    }
    setupCh(ch, peerId) { 
        ch.onmessage = e => onNetData(JSON.parse(e.data), peerId); 
        ch.onopen = () => {
            console.log(`DataChannel abierto con P${peerId}`);
            sendProfileUpdate();
            if(this.id === 1) this.send({ t:'lobby_sync_full', list: state.lobbyPlayers });
        };
    }
    send(d) { 
        const msg = JSON.stringify(d);
        for(let pid in this.peers) {
            const p = this.peers[pid];
            if(p.ch && p.ch.readyState==='open') p.ch.send(msg);
        }
    }
    broadcast(d) { this.send(d); }
}

// --- JUEGO ---
class Player {
    constructor(id, col, row, name, colorIdx) {
        this.id = id;
        this.name = name;
        this.colorIdx = colorIdx;
        this.spawnX = col * CONFIG.TILE; this.spawnY = row * CONFIG.TILE;
        this.activeBombs = 0;
        this.sentIdlePacket = true;
        this.reset();
    }
    reset() {
        this.x = this.spawnX; this.y = this.spawnY;
        this.targetX = this.x; this.targetY = this.y;
        this.isMoving = false; this.isDead = false;
        this.animState = 'IDLE_DOWN'; this.facingLeft = false;
        this.deadTimer = 0; this.activeBombs = 0;
        this.sentIdlePacket = true;
    }
    die() { 
        if(this.isDead) return; 
        this.isDead = true; 
        this.animState = 'DIE'; 
        this.deadTimer = 90; 
    }
    update() {
        if (this.isDead) {
            if (this.deadTimer > 0) this.deadTimer--;
            else if (this.deadTimer === 0) {
                this.deadTimer = -1;
                this.reset(); 
                if(this.id === net.id) net.send({ t:'respawn', id:this.id });
            }
            return;
        }
        if (this.isMoving) {
            if (this.id === net.id) {
                if (this.targetY > this.y) this.animState = 'WALK_DOWN';
                else if (this.targetY < this.y) this.animState = 'WALK_UP';
                else if (this.targetX > this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = false; }
                else if (this.targetX < this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = true; }
            }
            if (this.x < this.targetX) this.x += CONFIG.SPEED;
            if (this.x > this.targetX) this.x -= CONFIG.SPEED;
            if (this.y < this.targetY) this.y += CONFIG.SPEED;
            if (this.y > this.targetY) this.y -= CONFIG.SPEED;
            if (this.x === this.targetX && this.y === this.targetY) {
                this.isMoving = false;
                this.checkInput();
            }
        } else {
            if (this.id === net.id) {
                if (this.animState === 'WALK_DOWN') this.animState = 'IDLE_DOWN';
                if (this.animState === 'WALK_UP') this.animState = 'IDLE_UP';
                if (this.animState === 'WALK_SIDE') this.animState = 'IDLE_SIDE';
            }
            this.checkInput();
        }
    }
    checkInput() {
        if (this.id !== net.id) return; 
        if (state.winner) return;
        if (state.input.active) {
            let col = Math.round(this.x / CONFIG.TILE);
            let row = Math.round(this.y / CONFIG.TILE);
            let nextCol = col + state.input.x;
            let nextRow = row + state.input.y;
            if (nextCol < 0 || nextCol >= CONFIG.COLS || nextRow < 0 || nextRow >= CONFIG.ROWS) return;
            if (mapGrid[nextRow][nextCol] !== TILE_TYPE.EMPTY) return; 
            const bombAtDest = bombs.find(b => b.col === nextCol && b.row === nextRow);
            if (bombAtDest) return;
            
            this.targetX = nextCol * CONFIG.TILE;
            this.targetY = nextRow * CONFIG.TILE;
            this.isMoving = true;
            this.sentIdlePacket = false; 
            let nextAnim = this.animState;
            let facing = this.facingLeft;
            if(state.input.y > 0) nextAnim = 'WALK_DOWN';
            else if(state.input.y < 0) nextAnim = 'WALK_UP';
            else if(state.input.x > 0) { nextAnim = 'WALK_SIDE'; facing = false; }
            else if(state.input.x < 0) { nextAnim = 'WALK_SIDE'; facing = true; }
            net.send({ t:'m', tx:this.targetX, ty:this.targetY, x:this.x, y:this.y, id:this.id, a: nextAnim, f: facing });
        } else {
            if (!this.sentIdlePacket) {
                let idleAnim = this.animState;
                if(idleAnim.startsWith('WALK_DOWN')) idleAnim = 'IDLE_DOWN';
                if(idleAnim.startsWith('WALK_UP')) idleAnim = 'IDLE_UP';
                if(idleAnim.startsWith('WALK_SIDE')) idleAnim = 'IDLE_SIDE';
                this.animState = idleAnim;
                net.send({ t:'m', tx:this.x, ty:this.y, x:this.x, y:this.y, id:this.id, a: idleAnim, f: this.facingLeft });
                this.sentIdlePacket = true;
            }
        }
    }
    placeBomb() {
        if (this.isDead || this.activeBombs >= CONFIG.MAX_BOMBS || state.winner) return;
        const c = Math.round(this.x / CONFIG.TILE);
        const r = Math.round(this.y / CONFIG.TILE);
        if (mapGrid[r][c] === TILE_TYPE.BOMB) return; 
        if (bombs.some(b => b.col === c && b.row === r)) return;
        createBomb(c, r, this.id);
        this.activeBombs++;
        net.send({ t:'b', c:c, r:r, oid:this.id });
    }
    draw(ctx) {
        if (this.isDead && this.deadTimer <= 0) return; 
        const animData = SPRITES.CHAR[this.animState];
        let frameIdx = 0;
        if (this.animState === 'DIE') {
            const total = animData.length;
            frameIdx = Math.min(Math.floor((1 - (this.deadTimer / 90)) * total), total - 1);
        } else frameIdx = Math.floor(state.frame / 10) % animData.length;
        const coords = animData[frameIdx];
        // FIX BLUR: Usar enteros para dibujar
        const drawX = Math.floor(this.x); 
        const drawY = Math.floor(this.y - 8); 
        
        ctx.save();
        if (this.facingLeft) {
            ctx.translate(drawX + CONFIG.TILE, drawY);
            ctx.scale(-1, 1);
            drawSprite(ctx, coords, 0, 0, this.colorIdx);
        } else {
            drawSprite(ctx, coords, drawX, drawY, this.colorIdx);
        }
        ctx.restore();

        if (!this.isDead) {
            // INDICADOR TRIÃNGULO (Performance Maxima vs Texto)
            const colors = { 0:'#ac3232', 1:'#3498db', 2:'#2ecc71', 3:'#f1c40f', 4:'#9b59b6', 5:'#00cec9' };
            ctx.fillStyle = colors[this.colorIdx] || '#fff';
            ctx.beginPath();
            ctx.moveTo(Math.floor(this.x + 16), Math.floor(this.y - 12));
            ctx.lineTo(Math.floor(this.x + 12), Math.floor(this.y - 18));
            ctx.lineTo(Math.floor(this.x + 20), Math.floor(this.y - 18));
            ctx.fill();
        }
    }
}

class Bomb {
    constructor(col, row, ownerId) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 180; this.exploded = false;
    }
    update() { if(this.exploded) return true; this.timer--; return this.timer <= 0; }
    detonate() { this.timer = 0; this.exploded = true; }
    draw(ctx) {
        const frames = SPRITES.BOMB_IDLE;
        const idx = Math.floor(state.frame / 15) % frames.length;
        drawSprite(ctx, frames[idx], this.col*CONFIG.TILE, this.row*CONFIG.TILE);
    }
}

class Explosion {
    constructor(col, row, ownerId, type) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 30; this.sprite = type === 'center' ? SPRITES.EXPLOSION_CENTER : SPRITES.EXPLOSION_MID;
    }
    update() { 
        this.timer--; 
        checkPlayerHit(this.col, this.row, state.localPlayer, this.ownerId);
        for(let pid in state.players) checkPlayerHit(this.col, this.row, state.players[pid], this.ownerId);
        return this.timer <= 0; 
    }
    draw(ctx) { if (Math.floor(this.timer/3)%2===0) drawSprite(ctx, this.sprite, this.col*CONFIG.TILE, this.row*CONFIG.TILE); }
}

function checkPlayerHit(c, r, player, killerId) {
    if (!player || player.isDead || state.winner) return;
    if (Math.round(player.x / CONFIG.TILE) === c && Math.round(player.y / CONFIG.TILE) === r) {
        player.die(); 
        updateScore(killerId, player.id);
    }
}

function updateScore(killerId, victimId) {
    if (state.processingDeath || state.winner) return;
    state.processingDeath = true; 
    setTimeout(() => state.processingDeath = false, 500);
    if (killerId === victimId) state.scores[killerId] = Math.max(0, (state.scores[killerId] || 0) - 1);
    else { if(!state.scores[killerId]) state.scores[killerId] = 0; state.scores[killerId]++; }
    renderLobbySlots(); 
    checkWinCondition();
}

function checkWinCondition() {
    for(let pid in state.scores) {
        if(state.scores[pid] >= CONFIG.WIN_SCORE) {
            const pName = state.lobbyPlayers[pid] ? state.lobbyPlayers[pid].name : `P${pid}`;
            endGame(pName, `LlegÃ³ a ${CONFIG.WIN_SCORE} puntos`);
            return;
        }
    }
}

function endGame(winnerName, reason) {
    state.winner = winnerName;
    document.getElementById('game-over-overlay').style.display = 'flex';
    document.getElementById('winner-text').innerText = `GANADOR ${winnerName}`;
    document.getElementById('winner-reason').innerText = reason;
}

function updateHUD() {
    const timerEl = document.getElementById('timer-box');
    if(timerEl) {
        timerEl.innerText = state.timeLeft;
        timerEl.style.color = state.timeLeft < 10 ? '#e74c3c' : '#fff';
    }
}

function drawSprite(ctx, coord, x, y, colorIdx = -1) {
    if (!assets.loaded || !coord) return;
    
    // Seleccionar hoja fuente (cachÃ© o normal)
    let source = assets.spritesheet;
    if (colorIdx >= 0 && assets.coloredSheets[colorIdx]) {
        source = assets.coloredSheets[colorIdx];
    }

    ctx.drawImage(source, coord.x*32, coord.y*32, 32, 32, x, y, 32, 32);
}

// --- MAIN LOOP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const net = new Net();

window.onload = loadAssets;

function init() {
    ctx.imageSmoothingEnabled = false; // FIX BLUR
    window.addEventListener('resize', resizeViewport);
    setupInputs();
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('gamepad-area').style.display = 'flex';
    }
    resizeViewport();
    generateMap(); 
    requestAnimationFrame(gameLoop);
}

function connectToServer() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    document.getElementById('btnConnect').disabled = true;
    document.getElementById('btnConnect').innerText = "...";
    net.connect(room.toUpperCase());
}

function enterLobby(myId) {
    state.status = 'LOBBY';
    document.getElementById('screen-login').style.display = 'none';
    document.getElementById('screen-lobby').style.display = 'flex';
    sendProfileUpdate();
    if(myId === 1) {
        document.getElementById('btnStartGame').style.display = 'block';
        document.getElementById('btnStartGame').disabled = false;
        document.getElementById('lobby-msg').innerText = "Eres el HOST. Espera jugadores y dale a Iniciar.";
    }
}

function hostStartGame() {
    if(net.id !== 1) return;
    generateMap();
    state.timeLeft = CONFIG.ROUND_TIME; 
    net.send({ t:'start', grid:mapGrid });
    beginGameLoop();
}

function beginGameLoop() {
    state.status = 'GAME';
    document.getElementById('screen-lobby').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    for(let i=1; i<=4; i++) document.getElementById(`p${i}-score`).style.display = 'block';
    
    // Inicializar jugador local
    const info = getSpawnInfo(net.id);
    const myData = state.lobbyPlayers[net.id] || {name:`P${net.id}`, colorIdx:0};
    state.localPlayer = new Player(net.id, info.x, info.y, myData.name, myData.colorIdx);

    // Inicializar jugadores remotos inmediatamente para que sean visibles
    for(let pid in state.lobbyPlayers) {
        pid = parseInt(pid);
        if(pid !== net.id) {
            const pInfo = getSpawnInfo(pid);
            const pData = state.lobbyPlayers[pid];
            state.players[pid] = new Player(pid, pInfo.x, pInfo.y, pData.name, pData.colorIdx);
        }
    }
}

function onNetData(d, peerId) {
    const targetId = d.id || peerId;
    if (d.t === 'profile_update') { updateLobbyData(d.id, d.name, d.cIdx, d.rdy); return; }
    if (d.t === 'lobby_sync_full') { for(let pid in d.list) updateLobbyData(pid, d.list[pid].name, d.list[pid].colorIdx, d.list[pid].isReady); return; }

    if (state.status === 'LOBBY') {
        if(d.t === 'start') { mapGrid = d.grid; beginGameLoop(); }
        return;
    }
    if (state.status === 'GAME') {
        if (d.t === 'tick') { state.timeLeft = d.time; updateHUD(); return; }
        if (d.t === 'game_over') { 
            const pName = state.lobbyPlayers[d.winner] ? state.lobbyPlayers[d.winner].name : `P${d.winner}`;
            endGame(pName, "Â¡Tiempo Agotado!"); return; 
        }
        if (d.t === 'reset_round') {
            mapGrid = d.grid;
            if(state.localPlayer) state.localPlayer.reset();
            for(let k in state.players) state.players[k].reset();
            return;
        }
        let p = state.players[targetId];
        if (d.t === 'm') {
            if(!p) {
                const info = getSpawnInfo(targetId);
                const pData = state.lobbyPlayers[targetId] || {name:`P${targetId}`, colorIdx:0};
                state.players[targetId] = new Player(targetId, info.x, info.y, pData.name, pData.colorIdx);
                p = state.players[targetId];
            }
            p.x = d.x; p.y = d.y; p.targetX = d.tx; p.targetY = d.ty; p.isMoving = true;
            if(d.a) p.animState = d.a;
            if(typeof d.f !== 'undefined') p.facingLeft = d.f;
        }
        if (d.t === 'b') createBomb(d.c, d.r, d.oid);
        if (d.t === 'respawn' && p) p.reset();
    }
}

function getSpawnInfo(id) {
    const x = (id===1 || id===4) ? 1 : CONFIG.COLS - 2;
    const y = (id===1 || id===3) ? 1 : CONFIG.ROWS - 2;
    return { x: x, y: y };
}

function generateMap() {
    mapGrid = [];
    const safeZone = (c, r) => (c<=2 && r<=2) || (c>=CONFIG.COLS-3 && r>=CONFIG.ROWS-3) || (c>=CONFIG.COLS-3 && r<=2) || (c<=2 && r>=CONFIG.ROWS-3);
    for(let r=0; r<CONFIG.ROWS; r++) {
        let row = [];
        for(let c=0; c<CONFIG.COLS; c++) {
            if (r===0 || c===0 || r===CONFIG.ROWS-1 || c===CONFIG.COLS-1 || (r%2===0 && c%2===0)) row.push(TILE_TYPE.WALL);
            else if (!safeZone(c,r) && Math.random() < CONFIG.BRICK_DENSITY) row.push(TILE_TYPE.BRICK);
            else row.push(TILE_TYPE.EMPTY);
        }
        mapGrid.push(row);
    }
}

function createBomb(c, r, ownerId) { mapGrid[r][c] = TILE_TYPE.BOMB; bombs.push(new Bomb(c, r, ownerId)); }
function explode(bomb) {
    const centerC = bomb.col; const centerR = bomb.row; const ownerId = bomb.ownerId;
    if (state.localPlayer && state.localPlayer.id === ownerId) state.localPlayer.activeBombs--;
    else if (state.players[ownerId]) state.players[ownerId].activeBombs--;
    mapGrid[centerR][centerC] = TILE_TYPE.EMPTY;
    explosions.push(new Explosion(centerC, centerR, ownerId, 'center')); 
    const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; 
    dirs.forEach(dir => {
        for(let i=1; i<=CONFIG.BOMB_RANGE; i++) {
            const nc = centerC + (dir.x * i); const nr = centerR + (dir.y * i);
            if(nc<0 || nr<0 || nc>=CONFIG.COLS || nr>=CONFIG.ROWS) break;
            const type = mapGrid[nr][nc];
            if (type === TILE_TYPE.WALL) break; 
            if (type === TILE_TYPE.BRICK) { mapGrid[nr][nc] = TILE_TYPE.EMPTY; explosions.push(new Explosion(nc, nr, ownerId)); break; } 
            else if (type === TILE_TYPE.BOMB) {
                const chained = bombs.find(b => b.col === nc && b.row === nr && !b.exploded);
                if (chained) chained.detonate();
                explosions.push(new Explosion(nc, nr, ownerId));
            } else explosions.push(new Explosion(nc, nr, ownerId));
        }
    });
}

function checkMapReset() {
    let hasBricks = false;
    for(let r=0; r<CONFIG.ROWS; r++) {
        for(let c=0; c<CONFIG.COLS; c++) {
            if(mapGrid[r][c] === TILE_TYPE.BRICK) { hasBricks = true; break; }
        }
    }
    if(!hasBricks) {
        generateMap();
        if(state.localPlayer) state.localPlayer.reset();
        for(let k in state.players) state.players[k].reset();
        net.broadcast({t:'reset_round', grid:mapGrid});
    }
}

function resizeViewport() {
    const controlsH = document.getElementById('gamepad-area').style.display === 'flex' ? 240 : 0;
    const availW = window.innerWidth;
    const availH = window.innerHeight - controlsH;
    if (availH < 0) return; 
    const scale = Math.min(availW / CONFIG.WIDTH, availH / CONFIG.HEIGHT);
    const vp = document.getElementById('game-viewport');
    vp.style.width = (CONFIG.WIDTH * scale) + "px";
    vp.style.height = (CONFIG.HEIGHT * scale) + "px";
    canvas.width = CONFIG.WIDTH; 
    canvas.height = CONFIG.HEIGHT;
    ctx.imageSmoothingEnabled = false;
}

function gameLoop() { 
    state.frame++; 
    if(state.status === 'GAME') {
        update(); 
        draw(); 
        if(net.id === 1 && !state.winner) {
            if(state.frame % 60 === 0) { 
                state.timeLeft--;
                updateHUD();
                net.broadcast({t:'tick', time: state.timeLeft});
                if(state.timeLeft <= 0) {
                    let maxP = -1, winner = null;
                    for(let pid in state.scores) {
                        if(state.scores[pid] > maxP) { maxP = state.scores[pid]; winner = pid; }
                        else if(state.scores[pid] === maxP) winner = "EMPATE"; 
                    }
                    if(winner === "EMPATE") winner = null; 
                    net.broadcast({t:'game_over', winner: winner || 1});
                    const pName = state.lobbyPlayers[winner] ? state.lobbyPlayers[winner].name : `P${winner}`;
                    endGame(pName || 'EMPATE', "Â¡Tiempo Agotado!");
                }
            }
        }
    }
    requestAnimationFrame(gameLoop); 
}

function update() {
    if (state.localPlayer) state.localPlayer.update();
    for(let pid in state.players) state.players[pid].update(); 
    for (let i = bombs.length - 1; i >= 0; i--) { 
        const b = bombs[i]; 
        if (b.update()) { explode(b); bombs.splice(i, 1); if(net.id === 1) checkMapReset(); } 
    }
    for (let i = explosions.length - 1; i >= 0; i--) { if (explosions[i].update()) explosions.splice(i, 1); }
}

function draw() {
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<CONFIG.ROWS; r++) {
        for(let c=0; c<CONFIG.COLS; c++) {
            const x = c*CONFIG.TILE; const y = r*CONFIG.TILE;
            const cell = mapGrid[r][c];
            drawSprite(ctx, SPRITES.FLOOR, x, y);
            if (cell === TILE_TYPE.WALL) drawSprite(ctx, SPRITES.WALL_SOLID, x, y);
            else if (cell === TILE_TYPE.BRICK) drawSprite(ctx, SPRITES.WALL_BRICK, x, y);
        }
    }
    bombs.forEach(b => b.draw(ctx));
    explosions.forEach(e => e.draw(ctx));
    const allPlayers = [];
    if(state.localPlayer) allPlayers.push(state.localPlayer);
    for(let pid in state.players) allPlayers.push(state.players[pid]);
    allPlayers.sort((a,b) => a.y - b.y);
    allPlayers.forEach(p => p.draw(ctx));
}

function setupInputs() {
    const setDir = (x, y) => { state.input.x = x; state.input.y = y; state.input.active = (x!==0 || y!==0); };
    window.onkeydown = e => {
        if(e.repeat) return;
        if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
        if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
        if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
        if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
        if(e.code==='Space') { if(state.localPlayer) state.localPlayer.placeBomb(); }
    };
    window.onkeyup = e => { if(['ArrowUp','w','ArrowDown','s','ArrowLeft','a','ArrowRight','d'].includes(e.key)) setDir(0,0); };
    const btnAct = document.getElementById('action-btn');
    btnAct.addEventListener('touchstart', (e) => { e.preventDefault(); if(state.localPlayer) state.localPlayer.placeBomb(); }, {passive:false});
    bindTouch('btn-up',0,-1); bindTouch('btn-down',0,1); bindTouch('btn-left',-1,0); bindTouch('btn-right',1,0);
}
function bindTouch(id, x, y) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); state.input.x=x; state.input.y=y; state.input.active=true; el.style.opacity="0.6";}, {passive:false});
    el.addEventListener('touchend', (e) => { e.preventDefault(); state.input.active=false; el.style.opacity="1";});
}
function log(t) { if(document.getElementById('login-log')) document.getElementById('login-log').innerText = t; }
</script>
</body>
</html>