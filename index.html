<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BomberNet Engine v1.4 (4 Players & UI Fix)</title>
    <style>
        /* --- LAYOUT PRINCIPAL (Flex Column) --- */
        body {
            margin: 0; padding: 0;
            background-color: #111;
            height: 100vh; width: 100vw;
            display: flex; 
            flex-direction: column; /* Apilar verticalmente */
            align-items: center; 
            justify-content: center; /* Centrar si sobra espacio */
            overflow: hidden; 
            touch-action: none; 
            font-family: 'Courier New', monospace;
        }

        /* PANTALLA DE JUEGO (Arriba) */
        #game-viewport {
            position: relative;
            background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            /* Flex para ocupar espacio disponible pero respetar aspect ratio */
            flex-grow: 1; 
            max-width: 100%;
            max-height: 100%; /* No crecer más de la pantalla */
            display: flex; 
            justify-content: center;
            align-items: center;
        }

        canvas { 
            display: block; 
            /* El canvas se ajustará por JS manteniendo aspect ratio */
        }
        
        /* UI INTERNA (Menú) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
        }
        .panel { background: #2c3e50; border: 4px solid #fff; padding: 20px; text-align: center; }
        h1 { color: #f1c40f; margin: 0 0 15px 0; font-size: 24px; text-shadow: 2px 2px #c0392b; }
        input { padding: 10px; font-size: 16px; background: #000; color: #fff; border: 2px solid #555; text-align: center; display: block; margin: 0 auto 15px auto; width: 150px; font-family: inherit; text-transform: uppercase; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #e74c3c; color: white; border: 2px solid #fff; font-family: inherit; font-weight: bold; text-transform: uppercase; width: 100%; }
        button:active { background: #fff; color: #e74c3c; }
        button:disabled { background: #555; color: #888; border-color: #555; cursor: wait; }
        #status-log { font-size: 10px; color: #aaa; margin-top: 10px; }

        /* HUD (Puntuación 4 Jugadores) */
        #hud { 
            position: absolute; top: 0; left: 0; width: 100%; 
            display: flex; flex-wrap: wrap; justify-content: space-around; 
            padding: 5px; box-sizing: border-box; pointer-events: none; z-index: 10; 
        }
        .score-box { 
            background: rgba(0,0,0,0.6); padding: 2px 6px; color: white; 
            font-weight: bold; border: 1px solid rgba(255,255,255,0.3); 
            font-size: 10px; text-shadow: 1px 1px 0 #000; margin: 2px;
        }
        #p1-score { color: #3498db; } /* Azul */
        #p2-score { color: #e74c3c; } /* Rojo */
        #p3-score { color: #2ecc71; } /* Verde */
        #p4-score { color: #f1c40f; } /* Amarillo */

        /* --- CONTROLES GAMEPAD (Inferior - Fuera del juego) --- */
        #gamepad-area {
            display: none; /* JS lo activa en móvil */
            width: 100%;
            height: 180px; /* Altura fija cómoda */
            background: #1a1a1a;
            border-top: 2px solid #444;
            flex-direction: row;
            justify-content: space-between; /* D-PAD izq, Botón der */
            align-items: center;
            padding: 10px 20px; /* Padding lateral */
            box-sizing: border-box;
            flex-shrink: 0; /* No encogerse */
        }

        /* Estilos base de los botones */
        .gp-btn {
            position: absolute;
            background-image: url('sprites.png');
            background-repeat: no-repeat;
            image-rendering: pixelated;
            touch-action: none;
            opacity: 0.8;
            -webkit-tap-highlight-color: transparent; 
        }
        .gp-btn:active { opacity: 1.0; transform: scale(0.95); }

        /* === D-PAD === */
        .d-pad {
            position: relative; width: 150px; height: 150px;
            /* background: rgba(255,0,0,0.1); Debug */
        }
        
        /* Flechas (C4 = 64, 96) -> Escala 2x */
        .arrow-btn {
            width: 64px; height: 64px;
            background-size: 448px 256px; 
            background-position: -128px -192px; 
        }

        #btn-up    { left: 43px; top: 0; }
        #btn-down  { left: 43px; bottom: 0; transform: rotate(180deg); }
        #btn-left  { left: 0; top: 43px; transform: rotate(-90deg); }
        #btn-right { right: 0; top: 43px; transform: rotate(90deg); }

        #btn-down:active  { transform: rotate(180deg) scale(0.9); }
        #btn-left:active  { transform: rotate(-90deg) scale(0.9); }
        #btn-right:active { transform: rotate(90deg) scale(0.9); }

        /* === BOTÓN BOMBA (C2) === */
        /* C2 = 64, 32 -> Escala 2.5x */
        #action-wrapper {
            position: relative; width: 90px; height: 90px; display: flex; justify-content: center; align-items: center;
        }
        #action-btn {
            position: relative; 
            width: 80px; height: 80px;
            background-size: 560px 320px; 
            background-position: -160px -80px;
            
            background-color: #c0392b; 
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            box-shadow: 0 6px 0 #000;
        }
        #action-btn:active { 
            box-shadow: 0 3px 0 #000; 
            transform: translateY(3px); 
        }

    </style>
</head>
<body>

    <!-- VIEWPORT DEL JUEGO (Arriba) -->
    <div id="game-viewport">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD (Puntuación 4P) -->
        <div id="hud" style="display:none;">
            <div id="p1-score" class="score-box">P1: 0</div>
            <div id="p2-score" class="score-box">P2: 0</div>
            <div id="p3-score" class="score-box" style="display:none;">P3: 0</div>
            <div id="p4-score" class="score-box" style="display:none;">P4: 0</div>
        </div>

        <div id="ui-layer">
            <div class="panel">
                <h1>BomberNet</h1>
                <div style="font-size:10px; margin-bottom:10px;">v1.4 - 4 PLAYERS</div>
                <input type="text" id="roomInput" placeholder="CÓDIGO SALA" value="TEST" maxlength="6">
                <button id="btnPlay" onclick="startGame()">JUGAR</button>
                <div id="status-log">OFFLINE</div>
            </div>
        </div>
    </div>

    <!-- ZONA DE CONTROLES (Abajo - Fuera del Canvas) -->
    <div id="gamepad-area">
        <div class="d-pad">
            <div id="btn-up" class="gp-btn arrow-btn"></div>
            <div id="btn-down" class="gp-btn arrow-btn"></div>
            <div id="btn-left" class="gp-btn arrow-btn"></div>
            <div id="btn-right" class="gp-btn arrow-btn"></div>
        </div>
        <div id="action-wrapper">
            <div id="action-btn" class="gp-btn"></div>
        </div>
    </div>

<script>
// --- CONFIGURACIÓN ---
const CONFIG = {
    TILE: 32, COLS: 15, ROWS: 11,
    get WIDTH() { return this.COLS * this.TILE; },
    get HEIGHT() { return this.ROWS * this.TILE; },
    SPEED: 2, BRICK_DENSITY: 0.6, BOMB_RANGE: 2, MAX_BOMBS: 2
};

// --- ATLAS DE SPRITES ---
const SPRITES = {
    WALL_SOLID: {x:0, y:0}, WALL_BRICK: {x:1, y:0}, FLOOR: {x:0, y:1}, 
    BOMB_IDLE: [{x:0, y:2}, {x:1, y:2}], 
    EXPLOSION_CENTER: {x:2, y:2}, EXPLOSION_MID: {x:0, y:3}, EXPLOSION_END: {x:1, y:3}, 
    CHAR: {
        IDLE_DOWN: [{x:3, y:0}], WALK_DOWN: [{x:4, y:0}, {x:3, y:0}, {x:5, y:0}, {x:3, y:0}], 
        IDLE_SIDE: [{x:6, y:0}], WALK_SIDE: [{x:3, y:1}, {x:4, y:1}, {x:5, y:1}, {x:6, y:1}], 
        IDLE_UP: [{x:3, y:2}], WALK_UP: [{x:4, y:2}, {x:3, y:2}, {x:5, y:2}, {x:3, y:2}], 
        DIE: [{x:6, y:2}, {x:3, y:3}, {x:4, y:3}, {x:5, y:3}]  
    }
};

const assets = { spritesheet: new Image(), loaded: false };
assets.spritesheet.src = 'sprites.png';
assets.spritesheet.onload = () => { assets.loaded = true; };

// --- ESTADO GLOBAL ---
let mapGrid = [];
let bombs = []; 
let explosions = []; 
const TILE_TYPE = { EMPTY: 0, WALL: 1, BRICK: 2, BOMB: 3 };

const state = {
    running: false,
    input: { x: 0, y: 0, active: false },
    localPlayer: null,
    players: {}, // Mapa de jugadores remotos { id: Player }
    frame: 0,
    scores: { 1:0, 2:0, 3:0, 4:0 },
    processingDeath: false
};

// --- RED (Soporte Multi-Peer) ---
class Net {
    constructor() { 
        this.ws=null; 
        this.id=0;
        this.peers = {}; // { id: { rtc, ch } }
    }
    
    connect(room) {
        log("Conectando...");
        this.ws = new WebSocket('wss://bomber-server.onrender.com');
        this.ws.onopen = () => this.ws.send(JSON.stringify({type:'join', room:room}));
        this.ws.onmessage = e => this.handle(JSON.parse(e.data));
        this.ws.onerror = () => log("Error WS");
    }

    async handle(m) {
        switch(m.type) {
            case 'id': 
                this.id=m.id; 
                onConnected(m.id); 
                break;
            case 'peer_connected': 
                // Nuevo peer (m.id) se unió. Yo (Host o veterano) inicio conexión hacia él.
                // Nota: En una malla completa, idealmente el ID menor inicia, o el server orquesta.
                // Asumiremos que el server avisa a los existentes que conecten al nuevo.
                log(`Peer ${m.id} entró.`);
                this.initRTC(m.id, true); 
                break;
            case 'offer': 
                if(!this.peers[m.origin]) this.initRTC(m.origin, false);
                await this.peers[m.origin].rtc.setRemoteDescription(m.sdp);
                setTimeout(async()=>{
                    const a=await this.peers[m.origin].rtc.createAnswer();
                    await this.peers[m.origin].rtc.setLocalDescription(a);
                    this.sig({type:'answer', sdp:a, target:m.origin});
                }, 500);
                break;
            case 'answer': 
                if(this.peers[m.origin]) await this.peers[m.origin].rtc.setRemoteDescription(m.sdp); 
                break;
            case 'candidate': 
                if(this.peers[m.origin]) await this.peers[m.origin].rtc.addIceCandidate(m.candidate); 
                break;
            case 'peer_disconnected':
                // TODO: Server debería enviar ID de quién se fue
                // Por ahora limpiaremos si falla el canal
                break;
        }
    }

    sig(d) { 
        // Añadimos origen para saber de quién viene el mensaje en el server
        // (El servidor debería rebotar 'origin', pero lo simulamos aquí si el server es simple)
        if(this.ws) this.ws.send(JSON.stringify(d)); 
    }

    initRTC(peerId, offerer) {
        const rtc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        this.peers[peerId] = { rtc: rtc, ch: null };

        rtc.onicecandidate = e => { 
            if(e.candidate) this.sig({type:'candidate', candidate:e.candidate, target:peerId}); 
        };
        
        rtc.onconnectionstatechange = () => { 
            if(rtc.connectionState==='connected') onPeerJoin(peerId); 
            if(rtc.connectionState==='disconnected') onPeerLeft(peerId);
        };

        if(offerer) {
            const ch = rtc.createDataChannel("game", {ordered:false, maxRetransmits:0});
            this.peers[peerId].ch = ch;
            this.setupCh(ch, peerId);
            rtc.createOffer().then(o => { 
                rtc.setLocalDescription(o); 
                this.sig({type:'offer', sdp:o, target:peerId}); 
            });
        } else {
            rtc.ondatachannel = e => { 
                this.peers[peerId].ch = e.channel; 
                this.setupCh(e.channel, peerId); 
            };
        }
    }

    setupCh(ch, peerId) { 
        ch.onmessage = e => onNetData(JSON.parse(e.data), peerId); 
        ch.onopen = () => log(`P2P con ${peerId} LISTO`); 
    }

    send(d) { 
        // Broadcast a todos los peers conectados
        const msg = JSON.stringify(d);
        for(let pid in this.peers) {
            const p = this.peers[pid];
            if(p.ch && p.ch.readyState==='open') p.ch.send(msg);
        }
    }
}

// --- JUGADOR ---
class Player {
    constructor(id, col, row, colorTint) {
        this.id = id; this.tint = colorTint;
        this.spawnX = col * CONFIG.TILE; this.spawnY = row * CONFIG.TILE;
        this.activeBombs = 0;
        this.reset();
    }
    reset() {
        this.x = this.spawnX; this.y = this.spawnY;
        this.targetX = this.x; this.targetY = this.y;
        this.isMoving = false; this.isDead = false;
        this.animState = 'IDLE_DOWN'; this.facingLeft = false;
        this.deadTimer = 0; this.activeBombs = 0;
    }
    die() {
        if(this.isDead) return;
        this.isDead = true; this.animState = 'DIE'; this.deadTimer = 60;
    }
    update() {
        if (this.isDead) {
            if (this.deadTimer > 0) this.deadTimer--;
            else if (this.deadTimer === 0 && this.id === net.id) {
                this.deadTimer = -1; 
                setTimeout(() => { this.reset(); net.send({ t:'respawn', id:this.id }); }, 2000);
            }
            return;
        }
        if (this.isMoving) {
            if (this.targetY > this.y) this.animState = 'WALK_DOWN';
            else if (this.targetY < this.y) this.animState = 'WALK_UP';
            else if (this.targetX > this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = false; }
            else if (this.targetX < this.x) { this.animState = 'WALK_SIDE'; this.facingLeft = true; }
            
            if (this.x < this.targetX) this.x += CONFIG.SPEED;
            if (this.x > this.targetX) this.x -= CONFIG.SPEED;
            if (this.y < this.targetY) this.y += CONFIG.SPEED;
            if (this.y > this.targetY) this.y -= CONFIG.SPEED;

            if (this.x === this.targetX && this.y === this.targetY) {
                this.isMoving = false;
                this.checkInput();
            }
        } else {
            if (this.animState === 'WALK_DOWN') this.animState = 'IDLE_DOWN';
            if (this.animState === 'WALK_UP') this.animState = 'IDLE_UP';
            if (this.animState === 'WALK_SIDE') this.animState = 'IDLE_SIDE';
            this.checkInput();
        }
    }
    checkInput() {
        if (this.id !== net.id) return; 
        if (state.input.active) {
            let col = Math.round(this.x / CONFIG.TILE);
            let row = Math.round(this.y / CONFIG.TILE);
            let nextCol = col + state.input.x;
            let nextRow = row + state.input.y;
            if (nextCol < 0 || nextCol >= CONFIG.COLS || nextRow < 0 || nextRow >= CONFIG.ROWS) return;
            if (mapGrid[nextRow][nextCol] !== TILE_TYPE.EMPTY) return;
            this.targetX = nextCol * CONFIG.TILE;
            this.targetY = nextRow * CONFIG.TILE;
            this.isMoving = true;
            net.send({ t:'m', tx:this.targetX, ty:this.targetY, x:this.x, y:this.y, id:this.id });
        }
    }
    placeBomb() {
        if (this.isDead || this.activeBombs >= CONFIG.MAX_BOMBS) return;
        const c = Math.round(this.x / CONFIG.TILE);
        const r = Math.round(this.y / CONFIG.TILE);
        if (mapGrid[r][c] === TILE_TYPE.BOMB) return;
        createBomb(c, r, this.id);
        this.activeBombs++;
        net.send({ t:'b', c:c, r:r, oid:this.id });
    }
    draw(ctx) {
        if (this.isDead && this.deadTimer <= 0) return;
        const animData = SPRITES.CHAR[this.animState];
        let frameIdx = 0;
        if (this.animState === 'DIE') {
            const total = animData.length;
            frameIdx = Math.min(Math.floor((1 - (this.deadTimer / 60)) * total), total - 1);
        } else frameIdx = Math.floor(state.frame / 10) % animData.length;
        
        const coords = animData[frameIdx];
        const drawX = this.x; const drawY = this.y - 8; 
        if (this.facingLeft) {
            ctx.save(); ctx.scale(-1, 1);
            drawSprite(ctx, coords, -drawX - CONFIG.TILE, drawY);
            ctx.restore();
        } else drawSprite(ctx, coords, drawX, drawY);

        if (!this.isDead) {
            ctx.fillStyle = this.tint;
            ctx.beginPath();
            ctx.moveTo(this.x + 16, this.y - 12);
            ctx.lineTo(this.x + 12, this.y - 18);
            ctx.lineTo(this.x + 20, this.y - 18);
            ctx.fill();
        }
    }
}

class Bomb {
    constructor(col, row, ownerId) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 180; this.exploded = false;
    }
    update() { if(this.exploded) return true; this.timer--; return this.timer <= 0; }
    detonate() { this.timer = 0; this.exploded = true; }
    draw(ctx) {
        const frames = SPRITES.BOMB_IDLE;
        const speed = this.timer < 60 ? 5 : 15;
        const idx = Math.floor(state.frame / speed) % frames.length;
        drawSprite(ctx, frames[idx], this.col*CONFIG.TILE, this.row*CONFIG.TILE);
    }
}

class Explosion {
    constructor(col, row, ownerId, type) {
        this.col = col; this.row = row; this.ownerId = ownerId;
        this.timer = 30; this.sprite = type === 'center' ? SPRITES.EXPLOSION_CENTER : SPRITES.EXPLOSION_MID;
    }
    update() { 
        this.timer--; 
        // Hitbox para todos los jugadores
        checkPlayerHit(this.col, this.row, state.localPlayer, this.ownerId);
        for(let pid in state.players) {
            checkPlayerHit(this.col, this.row, state.players[pid], this.ownerId);
        }
        return this.timer <= 0; 
    }
    draw(ctx) { if (Math.floor(this.timer/3)%2===0) drawSprite(ctx, this.sprite, this.col*CONFIG.TILE, this.row*CONFIG.TILE); }
}

function checkPlayerHit(c, r, player, killerId) {
    if (!player || player.isDead) return;
    if (Math.round(player.x / CONFIG.TILE) === c && Math.round(player.y / CONFIG.TILE) === r) {
        player.die(); updateScore(killerId, player.id);
    }
}

function updateScore(killerId, victimId) {
    if (state.processingDeath) return;
    state.processingDeath = true; setTimeout(() => state.processingDeath = false, 1000);
    
    if(!state.scores[killerId]) state.scores[killerId] = 0;
    
    if (killerId === victimId) state.scores[killerId]--;
    else state.scores[killerId]++;
    
    updateHUD();
}

function updateHUD() {
    for(let i=1; i<=4; i++) {
        const el = document.getElementById(`p${i}-score`);
        if(el) el.innerText = `P${i}: ${state.scores[i] || 0}`;
    }
}

function drawSprite(ctx, coord, x, y) {
    if (assets.loaded && coord) ctx.drawImage(assets.spritesheet, coord.x*32, coord.y*32, 32, 32, x, y, 32, 32);
    else { ctx.fillStyle = "#ff00ff"; ctx.fillRect(x, y, 32, 32); }
}

// --- SISTEMA ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const net = new Net();

function init() {
    ctx.imageSmoothingEnabled = false;
    window.addEventListener('resize', resizeViewport);
    setupInputs();
    
    // Detectar táctil y mostrar gamepad
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('gamepad-area').style.display = 'flex';
        resizeViewport();
    } else {
        resizeViewport();
    }
    
    generateMap();
    requestAnimationFrame(gameLoop);
}

function generateMap() {
    mapGrid = [];
    // Zonas seguras para 4 esquinas
    const safeZone = (c, r) => {
        return (c<=2 && r<=2) ||                    // P1 (Arriba-Izq)
               (c>=CONFIG.COLS-3 && r>=CONFIG.ROWS-3) || // P2 (Abajo-Der)
               (c>=CONFIG.COLS-3 && r<=2) ||             // P3 (Arriba-Der)
               (c<=2 && r>=CONFIG.ROWS-3);               // P4 (Abajo-Izq)
    };

    for(let r=0; r<CONFIG.ROWS; r++) {
        let row = [];
        for(let c=0; c<CONFIG.COLS; c++) {
            if (r===0 || c===0 || r===CONFIG.ROWS-1 || c===CONFIG.COLS-1 || (r%2===0 && c%2===0)) row.push(TILE_TYPE.WALL);
            else if (!safeZone(c,r) && Math.random() < CONFIG.BRICK_DENSITY) row.push(TILE_TYPE.BRICK);
            else row.push(TILE_TYPE.EMPTY);
        }
        mapGrid.push(row);
    }
}

function createBomb(c, r, ownerId) { mapGrid[r][c] = TILE_TYPE.BOMB; bombs.push(new Bomb(c, r, ownerId)); }

function explode(bomb) {
    const centerC = bomb.col; const centerR = bomb.row; const ownerId = bomb.ownerId;
    
    // Liberar bomba del dueño (sea local o remoto)
    if (state.localPlayer && state.localPlayer.id === ownerId) state.localPlayer.activeBombs--;
    else if (state.players[ownerId]) state.players[ownerId].activeBombs--;

    mapGrid[centerR][centerC] = TILE_TYPE.EMPTY;
    explosions.push(new Explosion(centerC, centerR, ownerId, 'center')); 

    const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; 
    dirs.forEach(dir => {
        for(let i=1; i<=CONFIG.BOMB_RANGE; i++) {
            const nc = centerC + (dir.x * i); const nr = centerR + (dir.y * i);
            if(nc<0 || nr<0 || nc>=CONFIG.COLS || nr>=CONFIG.ROWS) break;
            const type = mapGrid[nr][nc];
            if (type === TILE_TYPE.WALL) break; 
            
            if (type === TILE_TYPE.BRICK) {
                mapGrid[nr][nc] = TILE_TYPE.EMPTY; explosions.push(new Explosion(nc, nr, ownerId)); break; 
            } else if (type === TILE_TYPE.BOMB) {
                const chained = bombs.find(b => b.col === nc && b.row === nr && !b.exploded);
                if (chained) chained.detonate();
                explosions.push(new Explosion(nc, nr, ownerId));
            } else explosions.push(new Explosion(nc, nr, ownerId));
        }
    });
}

function resizeViewport() {
    const controlsH = document.getElementById('gamepad-area').style.display === 'flex' ? 200 : 0;
    const availW = window.innerWidth;
    const availH = window.innerHeight - controlsH;

    if (availH < 0) return; 

    const scale = Math.min(availW / CONFIG.WIDTH, availH / CONFIG.HEIGHT);
    
    canvas.width = CONFIG.WIDTH; 
    canvas.height = CONFIG.HEIGHT;
    canvas.style.width = (CONFIG.WIDTH * scale) + "px";
    canvas.style.height = (CONFIG.HEIGHT * scale) + "px";
    
    ctx.imageSmoothingEnabled = false;
}

// --- LÓGICA JUEGO ---
function startGame() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    document.getElementById('btnPlay').disabled = true;
    document.getElementById('btnPlay').innerText = "...";
    net.connect(room.toUpperCase());
}

function getSpawnInfo(id) {
    // ID 1: Azul (Top-Left)
    // ID 2: Rojo (Bottom-Right)
    // ID 3: Verde (Top-Right)
    // ID 4: Amarillo (Bottom-Left)
    const colors = { 1: '#3498db', 2: '#e74c3c', 3: '#2ecc71', 4: '#f1c40f' };
    const x = (id===1 || id===4) ? 1 : CONFIG.COLS - 2;
    const y = (id===1 || id===3) ? 1 : CONFIG.ROWS - 2;
    return { c: colors[id] || '#fff', x: x, y: y };
}

function onConnected(id) {
    document.getElementById('ui-layer').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    
    // Mostrar scoreboards relevantes
    for(let i=1; i<=4; i++) {
        document.getElementById(`p${i}-score`).style.display = 'block';
    }

    net.id = id;
    const info = getSpawnInfo(id);
    state.localPlayer = new Player(id, info.x, info.y, info.c);
}

function onPeerJoin(id) {
    log(`JUGADOR ${id} SE UNIÓ`);
    if(!state.players[id]) {
        const info = getSpawnInfo(id);
        state.players[id] = new Player(id, info.x, info.y, info.c);
    }
    // Host sincroniza mapa con nuevos
    if(net.id === 1) net.send({ t:'map', grid: mapGrid });
}

function onPeerLeft(id) {
    log(`JUGADOR ${id} SALIÓ`);
    delete state.players[id];
}

function onNetData(d, peerId) {
    // Si recibimos datos de movimiento, actualizamos al player correspondiente
    const targetId = d.id || peerId; // Usar ID del paquete o del canal
    const p = state.players[targetId];

    if (d.t === 'm') {
        if(!p) {
            // Si no existe el player remoto (ej: entramos tarde), lo creamos
            const info = getSpawnInfo(targetId);
            state.players[targetId] = new Player(targetId, info.x, info.y, info.c);
            return;
        }
        p.x = d.x; p.y = d.y;
        p.targetX = d.tx; p.targetY = d.ty;
        p.isMoving = true;
    }
    if (d.t === 'b') createBomb(d.c, d.r, d.oid);
    if (d.t === 'map') mapGrid = d.grid;
    if (d.t === 'respawn' && p) p.reset();
}

function gameLoop() {
    state.frame++; update(); draw(); requestAnimationFrame(gameLoop);
}

function update() {
    if (state.localPlayer) state.localPlayer.update();
    
    // Actualizar todos los remotos
    for(let pid in state.players) {
        const p = state.players[pid];
        if (!p.isDead && p.isMoving) {
            if (p.x < p.targetX) p.x += CONFIG.SPEED;
            if (p.x > p.targetX) p.x -= CONFIG.SPEED;
            if (p.y < p.targetY) p.y += CONFIG.SPEED;
            if (p.y > p.targetY) p.y -= CONFIG.SPEED;
            if (p.x === p.targetX && p.y === p.targetY) p.isMoving = false;
        } else if (p.isDead) p.update(); 
    }

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        if (b.update()) { explode(b); bombs.splice(i, 1); }
    }
    for (let i = explosions.length - 1; i >= 0; i--) {
        if (explosions[i].update()) explosions.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<CONFIG.ROWS; r++) {
        for(let c=0; c<CONFIG.COLS; c++) {
            const x = c*CONFIG.TILE; const y = r*CONFIG.TILE;
            const cell = mapGrid[r][c];
            drawSprite(ctx, SPRITES.FLOOR, x, y);
            if (cell === TILE_TYPE.WALL) drawSprite(ctx, SPRITES.WALL_SOLID, x, y);
            else if (cell === TILE_TYPE.BRICK) drawSprite(ctx, SPRITES.WALL_BRICK, x, y);
        }
    }
    bombs.forEach(b => b.draw(ctx));
    explosions.forEach(e => e.draw(ctx));
    
    // Dibujar todos los players ordenados por Y
    const allPlayers = [];
    if(state.localPlayer) allPlayers.push(state.localPlayer);
    for(let pid in state.players) allPlayers.push(state.players[pid]);
    
    allPlayers.sort((a,b) => a.y - b.y);
    allPlayers.forEach(p => p.draw(ctx));
}

function setupInputs() {
    const setDir = (x, y) => { state.input.x = x; state.input.y = y; state.input.active = (x!==0 || y!==0); };
    window.onkeydown = e => {
        if(e.repeat) return;
        if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
        if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
        if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
        if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
        if(e.code==='Space') { if(state.localPlayer) state.localPlayer.placeBomb(); }
    };
    window.onkeyup = e => { if(['ArrowUp','w','ArrowDown','s','ArrowLeft','a','ArrowRight','d'].includes(e.key)) setDir(0,0); };
    
    const btnAct = document.getElementById('action-btn');
    btnAct.ontouchstart = e => { e.preventDefault(); if(state.localPlayer) state.localPlayer.placeBomb(); };
    bindTouch('btn-up',0,-1); bindTouch('btn-down',0,1); bindTouch('btn-left',-1,0); bindTouch('btn-right',1,0);
}
function bindTouch(id, x, y) {
    const el = document.getElementById(id);
    el.ontouchstart = e => { e.preventDefault(); state.input.x=x; state.input.y=y; state.input.active=true; };
    el.ontouchend = e => { e.preventDefault(); state.input.active=false; };
}
function log(t) { document.getElementById('status-log').innerText = t; }
window.onload = init;
</script>
</body>
</html>