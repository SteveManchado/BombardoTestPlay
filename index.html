<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BomberNet Engine v0.4</title>
    <style>
        /* --- ESTILOS IGUAL QUE ANTES (Resumidos) --- */
        body { margin: 0; padding: 0; background: #000; height: 100vh; width: 100vw; display: flex; align-items: center; justify-content: center; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
        #game-viewport { position: relative; background: #111; box-shadow: 0 0 0 2px #333; image-rendering: pixelated; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.8); z-index: 100; }
        .panel { background: #2c3e50; border: 4px solid #ecf0f1; padding: 20px; box-shadow: 8px 8px 0 #000; text-align: center; }
        h1 { color: #f1c40f; text-shadow: 2px 2px #c0392b; margin: 0 0 15px 0; font-size: 24px; }
        input { padding: 8px; font-size: 14px; background: #000; color: #fff; border: 2px solid #fff; font-family: inherit; text-transform: uppercase; text-align: center; display: block; margin: 0 auto 10px auto; width: 120px; }
        button { padding: 10px 20px; font-size: 14px; cursor: pointer; background: #e74c3c; color: white; border: 2px solid #fff; font-family: inherit; text-transform: uppercase; box-shadow: 4px 4px 0 #000; transition: transform 0.1s; }
        button:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #000; }
        button:disabled { background: #7f8c8d; cursor: not-allowed; }
        #status-log { font-size: 10px; color: #f1c40f; margin-top: 10px; }
        #mobile-controls { display: none; position: absolute; bottom: 10px; left: 10px; width: 140px; height: 140px; z-index: 50; }
        .d-pad-btn { position: absolute; width: 44px; height: 44px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.4); }
        .d-pad-btn:active { background: rgba(241, 196, 15, 0.5); }
        #btn-up { top: 0; left: 48px; } #btn-down { bottom: 0; left: 48px; } #btn-left { top: 48px; left: 0; } #btn-right { top: 48px; right: 0; }
        #action-btn { display: none; position: absolute; bottom: 20px; right: 20px; width: 64px; height: 64px; background: rgba(231, 76, 60, 0.4); border: 4px solid rgba(255,255,255,0.4); border-radius: 50%; z-index: 50; }
        #action-btn:active { background: rgba(231, 76, 60, 0.8); }
    </style>
</head>
<body>

    <div id="game-viewport">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="panel">
                <h1>BOMBERNET</h1>
                <div style="font-size: 10px; margin-bottom: 10px;">GRID ENGINE v0.4</div>
                <input type="text" id="roomInput" placeholder="SALA" value="TEST" maxlength="6">
                <button id="btnPlay" onclick="startGame()">CONECTAR</button>
                <div id="status-log">OFFLINE</div>
            </div>
        </div>
        <div id="mobile-controls">
            <div id="btn-up" class="d-pad-btn"></div>
            <div id="btn-down" class="d-pad-btn"></div>
            <div id="btn-left" class="d-pad-btn"></div>
            <div id="btn-right" class="d-pad-btn"></div>
        </div>
        <div id="action-btn"></div>
    </div>

<script>
// --- CONFIGURACIÓN ---
const CONFIG = {
    TILE: 32,
    COLS: 15,
    ROWS: 11,
    get WIDTH() { return this.COLS * this.TILE; },
    get HEIGHT() { return this.ROWS * this.TILE; },
    SPEED: 2
};

// --- MAPA LÓGICO (COLLISION MAP) ---
// 0: Suelo, 1: Pared Indestructible (Gris)
// Se generará dinámicamente en initGame()
let mapGrid = [];

const TILE_TYPE = {
    EMPTY: 0,
    WALL: 1,
    BLOCK: 2 // Reservado para futuro
};

// --- ESTADO GLOBAL ---
const state = {
    running: false,
    input: { x: 0, y: 0, active: false },
    localPlayer: null,
    remotePlayer: null
};

// --- RED ---
class Net {
    constructor() { this.ws=null; this.rtc=null; this.ch=null; this.id=0; }
    connect(room) {
        log("Conectando...");
        this.ws = new WebSocket('wss://bomber-server.onrender.com');
        this.ws.onopen = () => this.ws.send(JSON.stringify({type:'join', room:room}));
        this.ws.onmessage = e => this.handle(JSON.parse(e.data));
    }
    async handle(m) {
        switch(m.type) {
            case 'id': this.id = m.id; onConnected(m.id); break;
            case 'peer_connected': this.initRTC(true); break;
            case 'offer': 
                if(!this.rtc) this.initRTC(false);
                await this.rtc.setRemoteDescription(m.sdp);
                setTimeout(async()=>{
                    const a = await this.rtc.createAnswer();
                    await this.rtc.setLocalDescription(a);
                    this.sig({type:'answer', sdp:a});
                }, 100);
                break;
            case 'answer': await this.rtc.setRemoteDescription(m.sdp); break;
            case 'candidate': if(this.rtc) await this.rtc.addIceCandidate(m.candidate); break;
        }
    }
    sig(d) { if(this.ws) this.ws.send(JSON.stringify(d)); }
    initRTC(isOfferer) {
        this.rtc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        this.rtc.onicecandidate = e => { if(e.candidate) this.sig({type:'candidate', candidate:e.candidate}); };
        this.rtc.onconnectionstatechange = () => { if(this.rtc.connectionState==='connected') onPeerJoin(); };
        
        if(isOfferer) {
            this.ch = this.rtc.createDataChannel("game", {ordered:false, maxRetransmits:0});
            this.setupCh();
            this.rtc.createOffer().then(o => { this.rtc.setLocalDescription(o); this.sig({type:'offer', sdp:o}); });
        } else {
            this.rtc.ondatachannel = e => { this.ch = e.channel; this.setupCh(); };
        }
    }
    setupCh() { this.ch.onmessage = e => onNetData(JSON.parse(e.data)); }
    send(d) { if(this.ch && this.ch.readyState==='open') this.ch.send(JSON.stringify(d)); }
}

// --- JUEGO: JUGADOR ---
class Player {
    constructor(id, col, row, color) {
        this.id = id;
        this.color = color;
        this.x = col * CONFIG.TILE;
        this.y = row * CONFIG.TILE;
        
        this.isMoving = false;
        this.targetX = this.x;
        this.targetY = this.y;
    }

    update() {
        if (this.isMoving) {
            // Moverse hacia el objetivo
            if (this.x < this.targetX) this.x += CONFIG.SPEED;
            if (this.x > this.targetX) this.x -= CONFIG.SPEED;
            if (this.y < this.targetY) this.y += CONFIG.SPEED;
            if (this.y > this.targetY) this.y -= CONFIG.SPEED;

            if (this.x === this.targetX && this.y === this.targetY) {
                this.isMoving = false;
                this.checkInput(); // Encadenar movimiento si se mantiene pulsado
            }
        } else {
            this.checkInput();
        }
    }

    checkInput() {
        if (this.id !== net.id) return; 

        if (state.input.active) {
            // Calcular celda deseada (Grid Coordinates)
            let currentCol = Math.round(this.x / CONFIG.TILE);
            let currentRow = Math.round(this.y / CONFIG.TILE);
            
            let nextCol = currentCol + state.input.x;
            let nextRow = currentRow + state.input.y;

            // 1. CHEQUEO DE LÍMITES (Array Bounds)
            if (nextCol < 0 || nextCol >= CONFIG.COLS || nextRow < 0 || nextRow >= CONFIG.ROWS) {
                return; // Fuera del mapa, no nos movemos
            }

            // 2. CHEQUEO DE COLISIÓN (Paredes)
            // Si la celda destino NO es suelo (0), no nos movemos
            if (mapGrid[nextRow][nextCol] !== TILE_TYPE.EMPTY) {
                return; // Chocamos contra pared
            }

            // Si llegamos aquí, el camino es libre
            this.targetX = nextCol * CONFIG.TILE;
            this.targetY = nextRow * CONFIG.TILE;
            this.isMoving = true;
            
            net.send({ t:'m', tx:this.targetX, ty:this.targetY, x:this.x, y:this.y });
        }
    }

    draw(ctx) {
        // Dibujo
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x + 2, this.y + 2, CONFIG.TILE - 4, CONFIG.TILE - 4);
        
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x + 2, this.y + 2, CONFIG.TILE - 4, CONFIG.TILE - 4);

        ctx.fillStyle = "white";
        ctx.fillRect(this.x + 8, this.y + 8, 4, 4);
        ctx.fillRect(this.x + 20, this.y + 8, 4, 4);
    }
}

// --- SISTEMA ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const net = new Net();

function init() {
    ctx.imageSmoothingEnabled = false;
    resizeViewport();
    window.addEventListener('resize', resizeViewport);
    setupInputs();
    
    // Generar mapa inicial (Solo visual por ahora hasta que conectemos)
    generateMap(); 
    
    requestAnimationFrame(gameLoop);
}

function generateMap() {
    mapGrid = [];
    for(let r=0; r<CONFIG.ROWS; r++) {
        let row = [];
        for(let c=0; c<CONFIG.COLS; c++) {
            // Lógica Clásica Bomberman:
            // - Bordes son Pared (1)
            // - Celdas pares (2,2), (2,4)... son Pilares (1)
            // - El resto es Suelo (0)
            
            if (r===0 || c===0 || r===CONFIG.ROWS-1 || c===CONFIG.COLS-1) {
                row.push(TILE_TYPE.WALL);
            } else if (r%2===0 && c%2===0) {
                row.push(TILE_TYPE.WALL);
            } else {
                row.push(TILE_TYPE.EMPTY);
            }
        }
        mapGrid.push(row);
    }
}

function resizeViewport() {
    const scale = Math.min(window.innerWidth / CONFIG.WIDTH, window.innerHeight / CONFIG.HEIGHT);
    const vp = document.getElementById('game-viewport');
    vp.style.width = (CONFIG.WIDTH * scale) + "px";
    vp.style.height = (CONFIG.HEIGHT * scale) + "px";
    canvas.width = CONFIG.WIDTH;
    canvas.height = CONFIG.HEIGHT;
    ctx.imageSmoothingEnabled = false;
}

// --- LÓGICA JUEGO ---
function startGame() {
    const room = document.getElementById('roomInput').value;
    if(!room) return;
    document.getElementById('btnPlay').disabled = true;
    document.getElementById('btnPlay').innerText = "...";
    net.connect(room.toUpperCase());
}

function onConnected(id) {
    document.getElementById('ui-layer').style.display = 'none';
    net.id = id;
    // Spawn seguro: (1,1) para P1, (W-2, H-2) para P2
    // Estas coordenadas siempre son suelo (0) en nuestro algoritmo
    const c = id===1 ? '#3498db' : '#e74c3c';
    const cx = id===1 ? 1 : CONFIG.COLS - 2;
    const cy = id===1 ? 1 : CONFIG.ROWS - 2;
    
    state.localPlayer = new Player(id, cx, cy, c);
    
    if('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        document.getElementById('action-btn').style.display = 'block';
    }
}

function onPeerJoin() {
    log("Rival conectado");
    const rid = net.id===1 ? 2 : 1;
    const c = rid===1 ? '#3498db' : '#e74c3c';
    const cx = rid===1 ? 1 : CONFIG.COLS - 2;
    const cy = rid===1 ? 1 : CONFIG.ROWS - 2;
    state.remotePlayer = new Player(rid, cx, cy, c);
}

function onNetData(d) {
    if (state.remotePlayer && d.t === 'm') {
        state.remotePlayer.x = d.x;
        state.remotePlayer.y = d.y;
        state.remotePlayer.targetX = d.tx;
        state.remotePlayer.targetY = d.ty;
        state.remotePlayer.isMoving = true;
    }
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

function update() {
    if (state.localPlayer) state.localPlayer.update();
    
    if (state.remotePlayer) {
        const p = state.remotePlayer;
        if (p.isMoving) {
            // Movimiento remoto (sin chequeo de colisión, confiamos en el rival)
            if (p.x < p.targetX) p.x += CONFIG.SPEED;
            if (p.x > p.targetX) p.x -= CONFIG.SPEED;
            if (p.y < p.targetY) p.y += CONFIG.SPEED;
            if (p.y > p.targetY) p.y -= CONFIG.SPEED;
            if (p.x === p.targetX && p.y === p.targetY) p.isMoving = false;
        }
    }
}

function draw() {
    // Fondo
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Mapa basado en Matriz
    const T = CONFIG.TILE;
    for(let r=0; r<CONFIG.ROWS; r++) {
        for(let c=0; c<CONFIG.COLS; c++) {
            const x = c*T; const y = r*T;
            const cell = mapGrid[r][c];

            if (cell === TILE_TYPE.WALL) {
                // Pared
                ctx.fillStyle = "#7f8c8d";
                ctx.fillRect(x, y, T, T);
                // Sombra 3D simple
                ctx.fillStyle = "#555";
                ctx.fillRect(x, y+T-4, T, 4);
                ctx.fillRect(x+T-4, y, 4, T);
            } else {
                // Suelo
                ctx.fillStyle = (r+c)%2===0 ? "#27ae60" : "#2ecc71";
                ctx.fillRect(x, y, T, T);
            }
        }
    }

    if (state.remotePlayer) state.remotePlayer.draw(ctx);
    if (state.localPlayer) state.localPlayer.draw(ctx);
}

// --- INPUTS ---
function setupInputs() {
    const setDir = (x, y) => { state.input.x = x; state.input.y = y; state.input.active = (x!==0 || y!==0); };
    
    window.onkeydown = e => {
        if(e.repeat) return;
        if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
        if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
        if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
        if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
    };
    
    window.onkeyup = e => {
        if(['ArrowUp','w','ArrowDown','s','ArrowLeft','a','ArrowRight','d'].includes(e.key)) setDir(0,0);
    };

    bindTouch('btn-up',0,-1); bindTouch('btn-down',0,1);
    bindTouch('btn-left',-1,0); bindTouch('btn-right',1,0);
}

function bindTouch(id, x, y) {
    const el = document.getElementById(id);
    el.ontouchstart = e => { e.preventDefault(); state.input.x=x; state.input.y=y; state.input.active=true; };
    el.ontouchend = e => { e.preventDefault(); state.input.active=false; };
}

function log(t) { document.getElementById('status-log').innerText = t; }

window.onload = init;

</script>
</body>
</html>